/*
 *
 * Copyright 2018 Asylo authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include <google/protobuf/util/message_differencer.h>
#include <gmock/gmock.h>
#include <gtest/gtest.h>
#include "asylo/identity/identity.pb.h"
#include "asylo/identity/sgx/code_identity.pb.h"
#include "asylo/identity/sgx/fake_enclave.h"
#include "asylo/identity/sgx/local_assertion_generator.h"
#include "asylo/identity/sgx/local_assertion_verifier.h"
#include "asylo/identity/sgx/self_identity.h"
#include "asylo/platform/core/trusted_global_state.h"
#include "asylo/test/util/status_matchers.h"

namespace asylo {
namespace sgx {
namespace {

constexpr char kLocalAttestationDomain1[] = "A 16-byte string";
constexpr char kUserData[] = "User data";

// A test fixture is required for value-parameterized tests. The test fixture is
// also used to contain common test setup and tear down logic.
class LocalAssertionAuthorityTest
    : public ::testing::Test,
      public ::testing::WithParamInterface</*same_enclave=*/bool> {
 protected:
  void SetUp() override {
    EnclaveConfig enclave_config;
    enclave_config.mutable_host_config()->set_local_attestation_domain(
        kLocalAttestationDomain1);
    SetEnclaveConfig(enclave_config);

    // Create a FakeEnclave with a randomized identity for the generator.
    generator_enclave_.SetRandomIdentity();

    if (GetParam()) {
      // Use the same enclave for the verifier.
      verifier_enclave_ = generator_enclave_;
    } else {
      // Use a different enclave for the verifier.
      verifier_enclave_.SetRandomIdentity();
    }
  }

  void TearDown() override {
    // Exit the enclave on tear down since each test ends inside an enclave.
    // This ensures that execution is not inside an enclave at the start of a
    // test.
    FakeEnclave::ExitEnclave();
  }

  std::string config_;

  // The enclave in which the LocalAssertionGenerator runs.
  FakeEnclave generator_enclave_;

  // The enclave in which the LocalAssertionVerifier runs.
  FakeEnclave verifier_enclave_;
};

// Instantiate a test case that runs each test below in two different scenarios:
//   * Generator and verifier run in the same enclave
//   * Generator and verifier run in different enclaves (with the same local
//     attestation domain)
INSTANTIATE_TEST_CASE_P(RandomizedEnclaves, LocalAssertionAuthorityTest,
                        /*same_enclave=*/::testing::Bool());

// Verify that LocalAssertionGenerator can fulfill an assertion request from a
// LocalAssertionVerifier.
TEST_P(LocalAssertionAuthorityTest, CanGenerate) {
  FakeEnclave::EnterEnclave(verifier_enclave_);

  LocalAssertionVerifier verifier;
  ASSERT_THAT(verifier.Initialize(config_), IsOk());

  AssertionRequest request;
  ASSERT_THAT(verifier.CreateAssertionRequest(&request), IsOk());

  FakeEnclave::ExitEnclave();
  FakeEnclave::EnterEnclave(generator_enclave_);

  LocalAssertionGenerator generator;
  ASSERT_THAT(generator.Initialize(config_), IsOk());

  auto result = generator.CanGenerate(request);
  ASSERT_THAT(result, IsOk());
  EXPECT_TRUE(result.ValueOrDie());
}

// Verify that LocalAssertionVerifier can verify an assertion offered by a
// LocalAssertionGenerator.
TEST_P(LocalAssertionAuthorityTest, CanVerify) {
  FakeEnclave::EnterEnclave(generator_enclave_);

  LocalAssertionGenerator generator;
  ASSERT_THAT(generator.Initialize(config_), IsOk());

  AssertionOffer offer;
  ASSERT_THAT(generator.CreateAssertionOffer(&offer), IsOk());

  FakeEnclave::ExitEnclave();
  FakeEnclave::EnterEnclave(verifier_enclave_);

  LocalAssertionVerifier verifier;
  ASSERT_THAT(verifier.Initialize(config_), IsOk());

  auto result = verifier.CanVerify(offer);
  ASSERT_THAT(result, IsOk());
  EXPECT_TRUE(result.ValueOrDie());
}

// Verify the LocalAssertionVerifier successfully verifies an assertion
// generated by a LocalAssertionGenerator.
TEST_P(LocalAssertionAuthorityTest, VerifyAssertionSameEnclave) {
  FakeEnclave::EnterEnclave(verifier_enclave_);

  LocalAssertionVerifier verifier;
  ASSERT_THAT(verifier.Initialize(config_), IsOk());

  AssertionRequest request;
  verifier.CreateAssertionRequest(&request);

  FakeEnclave::ExitEnclave();
  FakeEnclave::EnterEnclave(generator_enclave_);

  LocalAssertionGenerator generator;
  ASSERT_THAT(generator.Initialize(config_), IsOk());

  Assertion assertion;
  ASSERT_THAT(generator.Generate(kUserData, request, &assertion), IsOk());

  FakeEnclave::ExitEnclave();
  FakeEnclave::EnterEnclave(verifier_enclave_);

  // Verify the generator's assertion.
  EnclaveIdentity identity;
  ASSERT_THAT(verifier.Verify(kUserData, assertion, &identity), IsOk());

  CodeIdentity code_identity;
  ASSERT_TRUE(code_identity.ParseFromString(identity.identity()));

  FakeEnclave::ExitEnclave();
  FakeEnclave::EnterEnclave(generator_enclave_);

  // Verify that the extracted code identity matches the generator's identity.
  EXPECT_TRUE(google::protobuf::util::MessageDifferencer::Equals(
      code_identity, GetSelfIdentity()->identity))
      << "Extracted identity:\n"
      << code_identity.DebugString() << "\nExpected identity:\n"
      << GetSelfIdentity()->identity.DebugString();
}

}  // namespace
}  // namespace sgx
}  // namespace asylo
