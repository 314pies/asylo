# Google's Modifications to Intel's SGX Development Toolkit

## Top-level files added
  * `BUILD` to build with Bazel. Some targets use wrappers around `make` defined
    in `sgx_sdk.bzl`.
    - Changed `psw/ae/common/ProtobufSerializer` to work with a Bazel-controlled
      dependency instead of the system-installed `protobuf-compiler`.
  * `sgx_sdk.bzl` provides Skylark rules and macros to wrap `make` and provide
    tools to configure and sign enclave binaries with a debug test-only key.
  * `enclave_test_private.pem` is a DEBUG ONLY private key for signing test
    enclaves. It is generated and included in the linux_sgx patch file only for
    reproducible build purposes. A cautious user may generate another one to
    replace it in their Bazel cache or modify the patch file itself to apply
    a different PEM file. We used the following command to generate the PEM:

        openssl genrsa -3 -out enclave_test_private.pem 3072

    The key in `asylo/distrib/linux_sgx_2_2.patch` can be changed to a new
    PEM file (which must be named `enclave_test_private.pem`, since that is what
    the `sgx_sdk.bzl` build rules look for) with the following commands, which
    copy the patch before the PEM, write a new PEM, then copy the patch after
    the old PEM diff:

        OLD=linux_sgx_2_2.patch
        S="+++ enclave_test_private.pem"
        E="+-----END RSA PRIVATE KEY-----"
        START=$(( -2 + $(grep -n "${S}" "${OLD}" | tail -n 1 | sed 's/:.*//') ))
        END=$(( 1 + $(grep -n "${E}" "${OLD}" | tail -n 1 | sed 's/:.*//') ))
        NEW=$(mktemp)
        head "-n${START}" "${OLD}" > "${NEW}"
        diff -u /dev/null enclave_test_private.pem | filterdiff \
          --remove-timestamps >> "${NEW}"
        tail "-n+${END}" "${OLD}" >> "${NEW}"
        mv "${NEW}" "${OLD}"

    `grep` is piped to `tail` to skip finding its own command in this patch
    preamble. `grep -n` adds the line number to the beginning with `:` after, so
    strip off `:` and everything after to get a number to feed to `head` and
    `tail`. The `-2` is for `head` to not print either the starting line or the
    necessary preceding line of `--- /dev/null`. The `1 +` is so `tail` does not
    duplicate the END RSA line.


## Directories added
### `include/`

Contains header files that are forwarded from the Intel SGX SDK to external
consumers. The files are needed by Asylo.

  * `global_data.h`: forwards `common/inc/internal/global_data.h` for use by
    the Asylo implementation of `sbrk`.
  * `sgx.h`: forwards `common/inc/sgx.h`
  * `sgx_edger8r.h`: forwards `common/inc/sgx_edger8r.h` for use by edger8r
    output targets.
  * `sgx_error.h`: forwards `common/inc/sgx_error.h` for SGXErrorSpace.
  * `sgx_lfence.h`: forwards `common/inc/sgx_lfence.h` for timing attack
    hardening that SGX Edger8r adds to boundary-crossing functions.
  * `sgx_thread.h`: forwards `common/inc/sgx_thread.h` for Asylo's threading
    support in SGX.
  * `sgx_trts.h`: forwards `common/inc/sgx_trts.h` for SGX trusted applications.
  * `sgx_trts_exception.h`: forwards `common/inc/sgx_trts_exception.h` for Asylo
    support of exception handlers.
  * `sgx_urts.h`: forwards `common/inc/sgx.h`

### `runtime_support/`

Contains headers, functions, and symbols needed by SGX SDK and PSW.

  * `rts_config.h` is for sources that need non standard C library functions,
     e.g., `memset_s`.
  * `sgx_init_string_lib.c` provides a new version of `sgx_init_string_lib`
    because we are using newlib instead of Intel's tlibc.
  * `sgx_init_crypto_lib.c` provides a new version of `sgx_init_crypto_lib`
    because we are using BoringSSL instead of Intel's tlibcrypto.


## Modifications to Intel's SDK release 2.2 (in ``)
### Downstreamed PRs
* [PR210](https://github.com/intel/linux-sgx/pull/210): Language conformance to
  resolve conflict with newlib.
    - Affected files:
      + `external/crypto_px/include/ippbase.h`
      + `external/epid/ext/ipp/include/ippbase.h`
      + `external/epid-sdk-3.0.0/ext/ipp/include/ippbase.h`
      + `external/crypto_px/sources/include/cpudef.h`
    - *Details:* Removed definition of reserved symbols `__INT64` and `__UINT64`
      and instead use `int64_t` and `uint64_t` from `<stdint.h>`. A use of
      `__INT64` in `cpudef.h` is changed to use `Ipp64s` from `ippbase.h`.
* [PR297](https://github.com/intel/linux-sgx/pull/297): Quiet compiler warnings
  turned to errors in
    - `sdk/simulation/uae_service_sim/linux/platform_service_sim.cpp`:
      redefinition of `__STDC_FORMAT_MACROS` (add `#ifndef` guard around
      `#define`)
    - `sdk/tlibc/gen/spinlock.c`: add a comment that `_mm_pause`'s definition
      requires -ffreestanding.
    - `sign_tool/SignTool/elf_helper.h`: use `std::hex` instead of `hex`.
    - `sign_tool/SignTool/manage_metadata.cpp`: use `std::hex` instead of `hex`.
* [PR301](https://github.com/intel/linux-sgx/pull/301): Localize -O0 to
  necessary functions and add -fno-omit-frame-pointer.
    - Affected_files:
      + `u_instructions.cpp`
      + `t_instructions.cpp`
* [PR307](https://github.com/intel/linux-sgx/pull/307): Remove an unnecessary
  `#include` from gperftool.
* [PR309](https://github.com/intel/linux-sgx/pull/309): Remove unneeded #include
  of sgx_urts.h in sgx_uswitchless.
    - Affected files:
      + `common/inc/sgx_uswitchless.h`

### Pending PRs
* [PR222](https://github.com/intel/linux-sgx/pull/222): Generate different code
  for user exception handlers in edger8r.
    - Affected files:
      + `sdk/edger8r/linux/Ast.ml`: Represent an exception handler function.
      + `sdk/edger8r/linux/CodeGen.ml`: Produce a new exception handler bit.
      + `sdk/edger8r/linux/Lexer.mll`: Add an exeception_handler token.
      + `sdk/edger8r/linux/Parser.mly`: Add exception_handler to function
        grammar and build a modified AST.
* [PR223](https://github.com/intel/linux-sgx/pull/223): Integrate with edger8r
  exception handler code to provide user handlers.
    - Affected files:
      + `trts_internal.h`
      + `trts_nsp.cpp`
* [PR308](https://github.com/intel/linux-sgx/pull/308): Include sl_util.h to
  define the MIN macro before its use.
    - Affected files:
      + `common/inc/internal/mini_snprintf.h`

### Non-upstreamed changes
* `sdk/trts/init_enclave.cpp`: Remove a memset_s of the enclave heap since
  Asylo does not support heap_init and sbrk in the manner needed for the cleared
  memory address to be meaningful. Without this, do_init_enclave segfaults.
* `external/rdrand/src/config.h`: Added the output of `./configure`
  since the build is ported entirely to Bazel.
* `sdk/trts/trts_nsp.cpp`: add "no-stack-protector" attribute to
  `init_stack_guard` to avoid resorting to the build system.
* `sdk/trts/trts_ecall.cpp` added
  `g_ecall_table.ecall_table[ordinal].is_exception` to the check condition of
  g_dyn_entry_table check to allow exception handler ecalls to pass even during
  an ocall of the interrupted frame. This deflakes our signal handling.
* `psw/urts/enclave.h` `psw/urts/enclave.cpp` add a method `get_tcs_info` to
  `CEnclave` class to expose the tcs info.
  `sdk/simulation/urtssim/get_state.cpp` added to get the tcs state from tcs
  info.
  `psw/urts/linux/urts.cpp` `common/inc/sgx_urts.h` add a method
  `sgx_is_enclave_active` to get whether the simulation enclave is active.
* Static stack size increase.
    - Affected files:
      + `sdk/trts/trts_internal.h`
      + `sdk/trts/linux/trts_pic.h`
      + `common/inc/internal/metadata.h`
    - *Changes:*
      + the first two headers change `STATIC_STACK_SIZE` from `8*100` to `8*1024`
        to avoid crash in the Asylo signal handler.
      + The third header changes `STACK_SIZE_MIN` from `0x1000` to `0x3000` to
        make sure it's larger than the static stack size.
    - *Detail:* `STATIC_STACK_SIZE` of stack is allocated for each tcs, and when
      an exception is raised, the frame that enters enclave to deal with the
      exception shares the same tcs as the enclave frame being interrupted,
      hence uses the memory directly adjacent. It will overwrite the interrupted
      frame's stack when it overflows. Since the exception handler makes a few
      functions calls to enter enclave to handle the exception, when combined
      with the use of STL containers it's easy to exceed the original stack
      size.
* `sdk/trts/linux/x86_64/setcontext.S` stubs out `ucontext` and
  `__NR_rt_sigprocmask` since we don't have it working yet.
* `psw/ae/common/proto/messages.proto` add syntax statement.
* `psw/ae/common/src/ProtobufSerializer.h` remove unnecessary include of
  protobuf's message.h.
* `sdk/trts/trts_ecall.cpp` added `interrupted` as an argument to
  `do_ecall`, and only initialize thread data if it is false.
* `sdk/trts/trts_internal.h` added `interrupted` as an argument to
  `do_ecall`.
* `sdk/trts/trts.cpp` pass `interrupted` argument to `do_ecall`. If
  `cssa` is 0, `interrupted` is false, otherwise it's true.
* `psw/urts/linux/sig_handler.cpp` remove registering sgx signal
  handlers for SIGSEGV, SIGFPE, SIGBUS, and SIGTRAP.

--
diff -Nur common/inc/internal/elfheader/elf_common.h common/inc/internal/elfheader/elf_common.h
--- common/inc/internal/elfheader/elf_common.h
+++ common/inc/internal/elfheader/elf_common.h
@@ -30,6 +30,9 @@
 #ifndef _SYS_ELF_COMMON_H_
 #define	_SYS_ELF_COMMON_H_ 1
 
+#include <stddef.h>
+#include <stdint.h>
+
 typedef uint32_t u_int32_t;
 typedef uint32_t Elf_Symndx;
 
diff -Nur common/inc/internal/elfheader/elfstructs.h common/inc/internal/elfheader/elfstructs.h
--- common/inc/internal/elfheader/elfstructs.h
+++ common/inc/internal/elfheader/elfstructs.h
@@ -26,6 +26,9 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include <stddef.h>
+#include <stdint.h>
+
 typedef uint8_t		Elf_Byte;
 
 typedef uint32_t	Elf32_Addr;	/* Unsigned program address */
diff -Nur common/inc/internal/linux/linux-regs.h common/inc/internal/linux/linux-regs.h
--- common/inc/internal/linux/linux-regs.h
+++ common/inc/internal/linux/linux-regs.h
@@ -37,6 +37,7 @@
 #define LINUX_REGS_H__
 
 #if defined(__i386) || defined(__i386__)
+
 #  define LINUX32       1
 #  define SE_WORDSIZE   4
 
diff -Nur common/inc/internal/metadata.h common/inc/internal/metadata.h
--- common/inc/internal/metadata.h
+++ common/inc/internal/metadata.h
@@ -72,7 +72,7 @@
 #define SSA_NUM_MIN 2
 #define SSA_FRAME_SIZE_MIN 1
 #define SSA_FRAME_SIZE_MAX 2
-#define STACK_SIZE_MIN 0x1000
+#define STACK_SIZE_MIN 0x3000
 #define STACK_SIZE_MAX 0x40000
 #define HEAP_SIZE_MIN 0x1000
 #define HEAP_SIZE_MAX 0x1000000
diff -Nur common/inc/internal/mini_snprintf.h common/inc/internal/mini_snprintf.h
--- common/inc/internal/mini_snprintf.h
+++ common/inc/internal/mini_snprintf.h
@@ -52,6 +52,8 @@
 #include <stdarg.h>
 #include <limits.h>
 
+#include "sl_util.h"
+
 /*===========================================================================
  * Interface
  *===========================================================================*/
diff -Nur common/inc/internal/pcl_common.h common/inc/internal/pcl_common.h
--- common/inc/internal/pcl_common.h
+++ common/inc/internal/pcl_common.h
@@ -32,6 +32,10 @@
 #ifndef PCL_COMMON_H
 #define PCL_COMMON_H
 
+#include <stddef.h>
+#include <stdint.h>
+#include "sgx_tcrypto.h"
+
 /*
  * This file includes definition used by PCL library and encryption tool
  */
diff -Nur common/inc/internal/se_tcrypto_common.h common/inc/internal/se_tcrypto_common.h
--- common/inc/internal/se_tcrypto_common.h
+++ common/inc/internal/se_tcrypto_common.h
@@ -33,6 +33,11 @@
 #ifndef _SE_TCRYPTO_COMMON_H_
 #define _SE_TCRYPTO_COMMON_H_
 
+#include <limits.h>
+#include "openssl/bn.h"
+#include "openssl/ecdsa.h"
+#include "rts_config.h"
+
 #ifdef USE_SGXSSL
 
 
diff -Nur common/inc/internal/sgx_read_rand.h common/inc/internal/sgx_read_rand.h
--- common/inc/internal/sgx_read_rand.h
+++ common/inc/internal/sgx_read_rand.h
@@ -31,6 +31,8 @@
 
 #ifndef __SGX_READ_RAND_H__
 #define __SGX_READ_RAND_H__
+#include <stddef.h>
+#include <stdint.h>
 #include "sgx.h"
 #include "sgx_defs.h"
 #ifdef __cplusplus
diff -Nur common/inc/internal/sl_workers.h common/inc/internal/sl_workers.h
--- common/inc/internal/sl_workers.h
+++ common/inc/internal/sl_workers.h
@@ -70,7 +70,7 @@
 #ifndef SL_INSIDE_ENCLAVE /* Untrusted */
     pthread_t*                          threads;
 #else /* Trusted */
-    void*                               __unused;
+    void*                               field_is_unused;
 #endif /* SL_INSIDE_ENCLAVE */
 };
 
diff -Nur common/inc/sgx_pcl_guid.h common/inc/sgx_pcl_guid.h
--- common/inc/sgx_pcl_guid.h
+++ common/inc/sgx_pcl_guid.h
@@ -31,6 +31,9 @@
 
 #ifndef SGX_PCL_GUID_H
 #define SGX_PCL_GUID_H
+
+#include <stdint.h>
+
 /*
  * GUID enables coupling of PCL lib (e.g. libsgx_pcl.a) and sealed blob
  * Before the PCL unseals the sealed blob, the PCL must verify the AAD 
diff -Nur common/inc/sgx_trts.h common/inc/sgx_trts.h
--- common/inc/sgx_trts.h
+++ common/inc/sgx_trts.h
@@ -32,6 +32,7 @@
 #ifndef _SGX_TRTS_H_
 #define _SGX_TRTS_H_
 
+#include "rts_config.h"
 #include "sgx_error.h"
 #include "stddef.h"
 #include "sgx_defs.h"
diff -Nur common/inc/sgx_urts.h common/inc/sgx_urts.h
--- common/inc/sgx_urts.h
+++ common/inc/sgx_urts.h
@@ -96,6 +96,8 @@
 
 sgx_status_t SGXAPI sgx_destroy_enclave(const sgx_enclave_id_t enclave_id);
 
+int SGXAPI sgx_is_tcs_active(const sgx_enclave_id_t enclave_id);
+
 #ifdef __cplusplus
 }
 #endif
diff -Nur common/inc/sgx_uswitchless.h common/inc/sgx_uswitchless.h
--- common/inc/sgx_uswitchless.h
+++ common/inc/sgx_uswitchless.h
@@ -72,7 +72,6 @@
 #include "sgx_error.h"
 #include "sgx_eid.h"
 #include "sgx_defs.h"
-#include "sgx_urts.h"
 
 /*
  * A worker can be either trusted (executed inside enclave) or untrusted
diff -Nur common/inc/tlibc/string.h common/inc/tlibc/string.h
--- common/inc/tlibc/string.h
+++ common/inc/tlibc/string.h
@@ -79,7 +79,8 @@
 char * _TLIBC_CDECL_ strtok(char *, const char *);
 size_t _TLIBC_CDECL_ strxfrm(char *, const char *, size_t);
 size_t _TLIBC_CDECL_ strlcpy(char *, const char *, size_t);
-errno_t _TLIBC_CDECL_ memset_s(void *s, size_t smax, int c, size_t n);
+// Declared in rts_config.h
+//errno_t _TLIBC_CDECL_ memset_s(void *s, size_t smax, int c, size_t n);
 
 /*
  * Deprecated C99.
@@ -92,7 +93,8 @@
  */
 char * _TLIBC_CDECL_ strndup(const char *, size_t);
 size_t _TLIBC_CDECL_ strnlen(const char *, size_t);
-int    _TLIBC_CDECL_ consttime_memequal(const void *b1, const void *b2, size_t len);
+// Declared in rts_config.h
+//int    _TLIBC_CDECL_ consttime_memequal(const void *b1, const void *b2, size_t len);
 
 /*
  * Non-C99
diff -Nur common/src/linux/xsave_gnu.S common/src/linux/xsave_gnu.S
--- common/src/linux/xsave_gnu.S
+++ common/src/linux/xsave_gnu.S
@@ -34,6 +34,8 @@
 
 #include "linux/linux-regs.h"
 
+.section        .note.GNU-stack, "", %progbits
+
 .macro DO_XSAVEC
 #if defined(LINUX64)
     .byte   0x48, 0x0f, 0xc7, 0x21
diff -Nur common/src/sgx_profile.cpp common/src/sgx_profile.cpp
--- common/src/sgx_profile.cpp
+++ common/src/sgx_profile.cpp
@@ -38,7 +38,6 @@
 #include "sgx_profile.h"
 #include "se_time.h"
 #include <string.h>
-using namespace std;
 
 typedef struct _profile_item_t{
     const char *str;  /* tag */
@@ -46,7 +45,7 @@
     long long time;   /* current time */
 } profile_item_t;
 
-static vector<profile_item_t> profile_items;
+static std::vector<profile_item_t> profile_items;
 static int alloc_size;
 static int used_size;
 const int MALLOC_SIZE = 1000;
@@ -108,7 +107,7 @@
 {
     int i,j;
 
-    ofstream fs;
+    std::ofstream fs;
     fs.open(filename); /* do not overwritten previous value */
 
     fs << "freq: " << freq <<endl;
diff -Nur external/rdrand/src/config.h external/rdrand/src/config.h
--- external/rdrand/src/config.h
+++ external/rdrand/src/config.h
@@ -0,0 +1,53 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "Intel Software Network"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "librdrand"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "librdrand 1.1"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "librdrand"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.1"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define if using gcc and it supports RDRAND */
+#define HAVE_RDRAND_IN_GCC 1
diff -Nur external/tinyxml2/tinyxml2.cpp external/tinyxml2/tinyxml2.cpp
--- external/tinyxml2/tinyxml2.cpp
+++ external/tinyxml2/tinyxml2.cpp
@@ -410,16 +410,19 @@
             *output = (char)((input | BYTE_MARK) & BYTE_MASK);
             input >>= 6;
             /* fallthrough */
+            [[clang::fallthrough]];
         case 3:
             --output;
             *output = (char)((input | BYTE_MARK) & BYTE_MASK);
             input >>= 6;
             /* fallthrough */
+            [[clang::fallthrough]];
         case 2:
             --output;
             *output = (char)((input | BYTE_MARK) & BYTE_MASK);
             input >>= 6;
             /* fallthrough */
+            [[clang::fallthrough]];
         case 1:
             --output;
             *output = (char)(input | FIRST_BYTE_MARK[*length]);
diff -Nur psw/ae/common/inc/IAEMessage.h psw/ae/common/inc/IAEMessage.h
--- psw/ae/common/inc/IAEMessage.h
+++ psw/ae/common/inc/IAEMessage.h
@@ -37,7 +37,7 @@
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
 #pragma GCC diagnostic ignored "-Wconversion"
-#include "messages.pb.h"
+#include "psw/ae/common/proto/messages.pb.h"
 #pragma GCC diagnostic pop
 
 struct AEMessage{
diff -Nur psw/ae/common/proto/messages.proto psw/ae/common/proto/messages.proto
--- psw/ae/common/proto/messages.proto
+++ psw/ae/common/proto/messages.proto
@@ -30,6 +30,8 @@
  */
 
 
+syntax = "proto2";
+
 package aesm.message;
 
 message Request{
diff -Nur psw/ae/common/src/ProtobufSerializer.cpp psw/ae/common/src/ProtobufSerializer.cpp
--- psw/ae/common/src/ProtobufSerializer.cpp
+++ psw/ae/common/src/ProtobufSerializer.cpp
@@ -34,7 +34,6 @@
  */
 
 #include <ProtobufSerializer.h>
-#include <google/protobuf/message.h>
 #include <IAEMessage.h>
 
 #include <IAERequest.h>
diff -Nur psw/urts/cpu_features.h psw/urts/cpu_features.h
--- psw/urts/cpu_features.h
+++ psw/urts/cpu_features.h
@@ -32,6 +32,8 @@
 #ifndef _CPU_FEATURES_H_
 #define _CPU_FEATURES_H_
 
+#include <stdint.h>
+
 #include "cpuid.h"
 
 void get_cpu_features(uint64_t *__intel_cpu_feature_indicator, uint32_t *cpuinfo_table);
diff -Nur psw/urts/enclave.cpp psw/urts/enclave.cpp
--- psw/urts/enclave.cpp
+++ psw/urts/enclave.cpp
@@ -45,8 +45,6 @@
 #include "rts.h"
 
 
-using namespace std;
-
 int do_ecall(const int fn, const void *ocall_table, const void *ms, CTrustThread *trust_thread);
 int do_ocall(const bridge_fn_t bridge, void *ms);
 
@@ -388,7 +386,15 @@
     return &m_enclave_info;
 }
 
-
+#ifdef SE_SIM
+tcs_t *CEnclave::get_tcs_info() {
+  CTrustThread *trust_thread = get_tcs(ECMD_ECALL);
+  if (!trust_thread) {
+    return NULL;
+  }
+  return trust_thread->get_tcs();
+}
+#endif
 
 CTrustThread * CEnclave::get_tcs(int ecall_cmd)
 {
diff -Nur psw/urts/enclave.h psw/urts/enclave.h
--- psw/urts/enclave.h
+++ psw/urts/enclave.h
@@ -85,7 +85,10 @@
     void set_sealed_key(uint8_t *sealed_key);
     sgx_status_t init_uswitchless(const sgx_uswitchless_config_t* config);
     void destroy_uswitchless(void);
-	
+#ifdef SE_SIM
+    tcs_t *get_tcs_info();
+#endif
+
 private:
     CTrustThread * get_tcs(int ecall_cmd);
     void put_tcs(CTrustThread *trust_thread);
diff -Nur psw/urts/file.h psw/urts/file.h
--- psw/urts/file.h
+++ psw/urts/file.h
@@ -33,6 +33,8 @@
 #ifndef _FILE_H_
 #define _FILE_H_
 
+#include <stdint.h>
+
 typedef char*  prd_css_path_t;
 
 typedef struct _se_file_t {
diff -Nur psw/urts/linux/misc.cpp psw/urts/linux/misc.cpp
--- psw/urts/linux/misc.cpp
+++ psw/urts/linux/misc.cpp
@@ -34,10 +34,8 @@
 #include <dirent.h>
 #include <vector>
 
-using namespace std;
-
 //get all thread id of current process.
-void get_thread_set(vector<se_thread_id_t> &thread_vector)
+void get_thread_set(std::vector<se_thread_id_t> &thread_vector)
 {
     DIR*   dir = NULL;
     struct dirent* dirent = NULL;
diff -Nur psw/urts/linux/read_xcr0.h psw/urts/linux/read_xcr0.h
--- psw/urts/linux/read_xcr0.h
+++ psw/urts/linux/read_xcr0.h
@@ -33,6 +33,8 @@
 #ifndef _READ_XCR0_H_
 #define _READ_XCR0_H_
 
+#include <stdint.h>
+
 static inline uint64_t xgetbv(uint32_t index)
 {
     uint32_t eax, edx;
diff -Nur psw/urts/linux/sig_handler.cpp psw/urts/linux/sig_handler.cpp
--- psw/urts/linux/sig_handler.cpp
+++ psw/urts/linux/sig_handler.cpp
@@ -198,23 +198,11 @@
     }
     else
     {
-        sigdelset(&sig_act.sa_mask, SIGSEGV);
-        sigdelset(&sig_act.sa_mask, SIGFPE);
         sigdelset(&sig_act.sa_mask, SIGILL);
-        sigdelset(&sig_act.sa_mask, SIGBUS);
-        sigdelset(&sig_act.sa_mask, SIGTRAP);
     }
 
-    ret = sigaction(SIGSEGV, &sig_act, &g_old_sigact[SIGSEGV]);
-    if (0 != ret) abort();
-    ret = sigaction(SIGFPE, &sig_act, &g_old_sigact[SIGFPE]);
-    if (0 != ret) abort();
     ret = sigaction(SIGILL, &sig_act, &g_old_sigact[SIGILL]);
     if (0 != ret) abort();
-    ret = sigaction(SIGBUS, &sig_act, &g_old_sigact[SIGBUS]);
-    if (0 != ret) abort();
-    ret = sigaction(SIGTRAP, &sig_act, &g_old_sigact[SIGTRAP]);
-    if (0 != ret) abort();
 }
 
 //trust_thread is saved at stack for ocall.
diff -Nur psw/urts/linux/urts.cpp psw/urts/linux/urts.cpp
--- psw/urts/linux/urts.cpp
+++ psw/urts/linux/urts.cpp
@@ -29,7 +29,8 @@
  *
  */
 
-
+#include "arch.h"
+#include "enclave.h"
 #include "sgx_error.h"
 #include "sgx_urts.h"
 #include "sgx_uswitchless.h"
@@ -145,3 +146,20 @@
     return __sgx_create_enclave_ex(file_name, debug, launch_token,
         launch_token_updated, enclave_id, misc_attr, ex_features, ex_features_p);
 }
+
+extern "C" int is_tcs_sim_active(const tcs_t *tcs);
+
+extern "C" int sgx_is_tcs_active(const sgx_enclave_id_t enclave_id)
+{
+// In the non-sim case, tcs cannot be active because untrusted code cannot run
+// when it is active.
+#ifdef SE_SIM
+  CEnclave* enclave = CEnclavePool::instance()->get_enclave(enclave_id);
+  if (enclave)
+  {
+    tcs_t *tcs = enclave->get_tcs_info();
+    return is_tcs_sim_active(tcs);
+  }
+#endif
+  return 0;
+}
diff -Nur psw/urts/loader.cpp psw/urts/loader.cpp
--- psw/urts/loader.cpp
+++ psw/urts/loader.cpp
@@ -47,10 +47,14 @@
 #include <vector>
 #include <tuple>
 #include <algorithm>
+#ifndef __STDC_FORMAT_MACROS
 #define __STDC_FORMAT_MACROS
+#endif  // __STDC_FORMAT_MACROS
 #include <inttypes.h>
 #include <sys/mman.h>
 
+using std::pair;
+
 // enclave creator instance
 extern EnclaveCreator* g_enclave_creator;
 
@@ -103,7 +107,7 @@
 }
 
 // is_relocation_page returns true if the specified RVA is a writable relocation page based on the bitmap.
-bool CLoader::is_relocation_page(const uint64_t rva, vector<uint8_t> *bitmap)
+bool CLoader::is_relocation_page(const uint64_t rva, std::vector<uint8_t> *bitmap)
 {
     uint64_t page_frame = rva >> SE_PAGE_SHIFT;
     //NOTE:
@@ -181,7 +185,7 @@
     return SGX_SUCCESS;
 }
 
-int CLoader::build_sections(vector<uint8_t> *bitmap)
+int CLoader::build_sections(std::vector<uint8_t> *bitmap)
 {
     int ret = SGX_SUCCESS;
     std::vector<Section*> sections = m_parser.get_sections();
@@ -372,7 +376,7 @@
                 ptcs->ogs_base += rva;
                 if(!(attributes & PAGE_ATTR_EREMOVE))
                 {
-                    m_tcs_list.push_back(make_pair(GET_PTR(tcs_t, m_start_addr, rva), false));
+                    m_tcs_list.push_back(std::make_pair(GET_PTR(tcs_t, m_start_addr, rva), false));
                 }
                 sinfo.flags = layout->si_flags;
                 if(SGX_SUCCESS != (ret = build_pages(rva, ((uint64_t)layout->page_count) << SE_PAGE_SHIFT, added_page, sinfo, attributes)))
@@ -417,7 +421,7 @@
 #ifndef SE_SIM
         if(layout->id == LAYOUT_ID_TCS_DYN)
         {
-            m_tcs_list.push_back(make_pair(GET_PTR(tcs_t, m_start_addr, rva), true));
+            m_tcs_list.push_back(std::make_pair(GET_PTR(tcs_t, m_start_addr, rva), true));
         }
 #endif
     }
@@ -490,7 +494,7 @@
     // If load_enclave_ex try to load the enclave for the 2nd time,
     // the enclave image is already patched, and parser cannot read the information.
     // For linux, there's no map conflict. We assume load_enclave_ex will not do the retry.
-    vector<uint8_t> bitmap;
+    std::vector<uint8_t> bitmap;
     if(!m_parser.get_reloc_bitmap(bitmap))
         return SGX_ERROR_INVALID_ENCLAVE;
 
@@ -564,12 +568,12 @@
 {
     layout_t *layout_start = GET_PTR(layout_t, m_metadata, m_metadata->dirs[DIR_LAYOUT].offset);
     layout_t *layout_end = GET_PTR(layout_t, m_metadata, m_metadata->dirs[DIR_LAYOUT].offset + m_metadata->dirs[DIR_LAYOUT].size);
-    vector<pair<uint64_t, uint64_t>> rva_vector;
+    std::vector<std::pair<uint64_t, uint64_t>> rva_vector;
     for (layout_t *layout = layout_start; layout < layout_end; layout++)
     {
         if(!IS_GROUP_ID(layout->entry.id))  // layout entry
         {
-            rva_vector.push_back(make_pair(layout->entry.rva, ((uint64_t)layout->entry.page_count) << SE_PAGE_SHIFT));
+            rva_vector.push_back(std::make_pair(layout->entry.rva, ((uint64_t)layout->entry.page_count) << SE_PAGE_SHIFT));
             if(layout->entry.content_offset)
             {
                 if(false == is_metadata_buffer(layout->entry.content_offset, layout->entry.content_size))
@@ -598,7 +602,7 @@
                     {
                         return SGX_ERROR_INVALID_METADATA;
                     }
-                    rva_vector.push_back(make_pair(entry->rva + load_step, ((uint64_t)entry->page_count) << SE_PAGE_SHIFT));
+                    rva_vector.push_back(std::make_pair(entry->rva + load_step, ((uint64_t)entry->page_count) << SE_PAGE_SHIFT));
                     // no need to check integer overflow for entry->rva + load_step, because
                     // entry->rva and load_step are less than enclave_size, whose size is no more than 37 bit
                 }
@@ -606,7 +610,7 @@
         }
     }
     sort(rva_vector.begin(), rva_vector.end());
-    for (vector<pair<uint64_t, uint64_t>>::iterator it = rva_vector.begin(); it != rva_vector.end(); it++)
+    for (std::vector<pair<uint64_t, uint64_t>>::iterator it = rva_vector.begin(); it != rva_vector.end(); it++)
     {
         if(!IS_PAGE_ALIGNED(it->first))
         {
diff -Nur psw/urts/loader.h psw/urts/loader.h
--- psw/urts/loader.h
+++ psw/urts/loader.h
@@ -77,7 +77,7 @@
     int build_contexts(layout_t *layout_start, layout_t *layout_end, uint64_t delta);
     int build_partial_page(const uint64_t rva, const uint64_t size, const void *source, const sec_info_t &sinfo, const uint32_t attr);
     int build_pages(const uint64_t start_rva, const uint64_t size, const void *source, const sec_info_t &sinfo, const uint32_t attr);
-    bool is_relocation_page(const uint64_t rva, vector<uint8_t> *bitmap);
+    bool is_relocation_page(const uint64_t rva, std::vector<uint8_t> *bitmap);
 
     bool is_ae(const enclave_css_t *enclave_css);
     bool is_metadata_buffer(uint32_t offset, uint32_t size);
@@ -86,7 +86,7 @@
     int validate_patch_table();
     int validate_metadata();
     int get_debug_flag(const token_t * const launch);
-    virtual int build_sections(vector<uint8_t> *bitmap);
+    virtual int build_sections(std::vector<uint8_t> *bitmap);
     int set_context_protection(layout_t *layout_start, layout_t *layout_end, uint64_t delta);
 
     uint8_t             *m_mapped_file_base;
diff -Nur psw/urts/parser/binparser.h psw/urts/parser/binparser.h
--- psw/urts/parser/binparser.h
+++ psw/urts/parser/binparser.h
@@ -41,8 +41,6 @@
 #include <stdint.h>
 #include <vector>
 #include <string>
-using std::vector;
-using std::string;
 
 #define ENCLAVE_MAX_SIZE_32 0xffffffff
 #define ENCLAVE_MAX_SIZE_64 0x1fffffffff
@@ -77,17 +75,17 @@
     virtual const uint8_t* get_start_addr() const = 0;
 
     // Get a vector of sections to be loaded
-    virtual const vector<Section *>& get_sections() const = 0;
+    virtual const std::vector<Section *>& get_sections() const = 0;
 
     // Get the TLS section
     virtual const Section* get_tls_section() const = 0;
 
     virtual uint64_t get_symbol_rva(const char* name) const = 0;
 
-    virtual bool get_reloc_bitmap(vector<uint8_t> &bitmap) = 0;
+    virtual bool get_reloc_bitmap(std::vector<uint8_t> &bitmap) = 0;
 
     virtual void get_reloc_entry_offset(const char* sec_name,
-                                        vector<uint64_t>& offsets) = 0;
+                                        std::vector<uint64_t>& offsets) = 0;
 
     // !We need to put this method into BinParser class since
     // !the `global_data_t' is platform-dependent as the parser.
@@ -107,7 +105,7 @@
 
     virtual sgx_status_t get_info(enclave_diff_info_t *enclave_diff_info) = 0;
 
-    virtual void get_executable_sections(vector<const char *>& xsec_names) const = 0;
+    virtual void get_executable_sections(std::vector<const char *>& xsec_names) const = 0;
     virtual bool set_memory_protection(uint64_t enclave_base_addr, bool is_after_initialization) = 0;
     virtual void get_pages_to_protect(uint64_t, std::vector<std::tuple<uint64_t, uint64_t, uint32_t>>&) const = 0;
     virtual bool has_init_section() const = 0;
diff -Nur psw/urts/parser/elfparser.cpp psw/urts/parser/elfparser.cpp
--- psw/urts/parser/elfparser.cpp
+++ psw/urts/parser/elfparser.cpp
@@ -184,7 +184,7 @@
  * We only need to search `.dynsym' for undefined symbols.
  */
 bool check_symbol_table(const ElfW(Ehdr) *elf_hdr, const ElfW(Dyn) *dyn_info,
-                        map<string, uint64_t>& sym_table)
+                        std::map<std::string, uint64_t>& sym_table)
 {
     const ElfW(Shdr) *sh_symtab = get_section_by_addr(elf_hdr, dyn_info[DT_SYMTAB].d_un.d_ptr);
 
@@ -245,7 +245,7 @@
     // If the enclave if compiled/linked with -fpie/-pie, and setting the
     // enclave entry to `enclave_entry', the `st_name' for `enclave_entry'
     // will be 0 in `.dynsym'.
-    map<string, uint64_t>::const_iterator it = sym_table.find("enclave_entry");
+    std::map<std::string, uint64_t>::const_iterator it = sym_table.find("enclave_entry");
     if (it == sym_table.end())
     {
         sym_table["enclave_entry"] = (uint64_t)elf_hdr->e_entry;
@@ -504,7 +504,7 @@
 }
 
 bool build_regular_sections(const uint8_t* start_addr,
-                            vector<Section *>& sections,
+                            std::vector<Section *>& sections,
                             const Section*& tls_sec,
                             uint64_t& metadata_offset,
                             uint64_t& metadata_block_size)
@@ -565,7 +565,7 @@
     return true;
 }
 
-const Section* get_max_rva_section(const vector<Section*> sections)
+const Section* get_max_rva_section(const std::vector<Section*> sections)
 {
     size_t sec_size = sections.size();
 
@@ -672,7 +672,7 @@
     return m_start_addr;
 }
 
-const vector<Section *>& ElfParser::get_sections() const
+const std::vector<Section *>& ElfParser::get_sections() const
 {
     return m_sections;
 }
@@ -684,7 +684,7 @@
 
 uint64_t ElfParser::get_symbol_rva(const char* name) const
 {
-    map<string, uint64_t>::const_iterator it = m_sym_table.find(name);
+  std::map<std::string, uint64_t>::const_iterator it = m_sym_table.find(name);
     if (it != m_sym_table.end())
         return it->second;
     else
@@ -700,7 +700,7 @@
     return false;
 }
 
-bool ElfParser::get_reloc_bitmap(vector<uint8_t>& bitmap)
+bool ElfParser::get_reloc_bitmap(std::vector<uint8_t>& bitmap)
 {
     // Clear the `bitmap' so that it is in a known state
     bitmap.clear();
@@ -781,7 +781,7 @@
     return true;
 }
 
-void ElfParser::get_reloc_entry_offset(const char* sec_name, vector<uint64_t>& offsets)
+void ElfParser::get_reloc_entry_offset(const char* sec_name, std::vector<uint64_t>& offsets)
 {
     if (sec_name == NULL)
         return;
@@ -859,7 +859,7 @@
     return SGX_SUCCESS;
 }
 
-void ElfParser::get_executable_sections(vector<const char *>& xsec_names) const
+void ElfParser::get_executable_sections(std::vector<const char *>& xsec_names) const
 {
     xsec_names.clear();
 
diff -Nur psw/urts/parser/elfparser.h psw/urts/parser/elfparser.h
--- psw/urts/parser/elfparser.h
+++ psw/urts/parser/elfparser.h
@@ -39,9 +39,6 @@
 #include <string>
 #include <map>
 
-using std::map;
-using std::string;
-
 class ElfParser : public BinParser, private Uncopyable {
 public:
     // The `start_addr' cannot be NULL
@@ -63,11 +60,11 @@
 
     // The `section' here is a section in PE's concept.
     // It is in fact a `segment' in ELF's view.
-    const vector<Section *>& get_sections() const;
+    const std::vector<Section *>& get_sections() const;
     const Section* get_tls_section() const;
     uint64_t get_symbol_rva(const char* name) const;
 
-    bool get_reloc_bitmap(vector<uint8_t> &bitmap);
+    bool get_reloc_bitmap(std::vector<uint8_t> &bitmap);
     bool has_text_reloc() const;
     uint32_t get_global_data_size();
     bool update_global_data(const metadata_t *const metadata,
@@ -86,11 +83,11 @@
     // To check whether current enclave has any TEXTREL:
     //   get_reloc_entry_offset(".text", offsets);
     void get_reloc_entry_offset(const char* sec_name,
-                                vector<uint64_t>& offsets);
+                                std::vector<uint64_t>& offsets);
 
     sgx_status_t modify_info(enclave_diff_info_t *enclave_diff_info);
     sgx_status_t get_info(enclave_diff_info_t *enclave_diff_info);
-    void get_executable_sections(vector<const char *>& xsec_names) const;
+    void get_executable_sections(std::vector<const char *>& xsec_names) const;
     bool is_enclave_encrypted() const;
 
     bool set_memory_protection(uint64_t enclave_base_addr, bool is_after_initialization);
@@ -102,7 +99,7 @@
     const uint8_t*      m_start_addr;
     uint64_t            m_len;
     bin_fmt_t           m_bin_fmt;
-    vector<Section *>   m_sections;
+    std::vector<Section *>   m_sections;
     const Section*      m_tls_section;
     uint64_t            m_metadata_offset;
     uint64_t            m_metadata_block_size;/*multiple metadata block size*/
@@ -110,7 +107,7 @@
     ElfW(Dyn)           m_dyn_info[DT_NUM + DT_ADDRNUM];
 
     // A map from symbol name to its RVA
-    map<string, uint64_t> m_sym_table;
+    std::map<std::string, uint64_t> m_sym_table;
 };
 
 #endif
diff -Nur psw/urts/parser/update_global_data.hxx psw/urts/parser/update_global_data.hxx
--- psw/urts/parser/update_global_data.hxx
+++ psw/urts/parser/update_global_data.hxx
@@ -29,6 +29,13 @@
  *
  */
 
+#include <stdint.h>
+
+#include "create_param.h"
+#include "global_data.h"
+#include "loader.h"
+#include "thread_data.h"
+
 namespace {
     layout_entry_t *get_entry_by_id(const metadata_t *const metadata, uint16_t id)
     {
diff -Nur psw/urts/section_info.h psw/urts/section_info.h
--- psw/urts/section_info.h
+++ psw/urts/section_info.h
@@ -36,8 +36,6 @@
 #include "util.h"
 #include <vector>
 
-using namespace std;
-
 typedef struct _section_info_t
 {
     const uint8_t *raw_data;          //The file pointer to the first page of the section.
@@ -45,7 +43,7 @@
     uint64_t rva;               //The address of the first byte of the section relative to the image base when section is loaded into memory.
     uint64_t virtual_size;      //The total size of the section when loaded into memory.
     si_flags_t flag;            //the attribute of memory region.
-    vector<uint8_t> *bitmap;    //bitmap of the total image page, if bit is 1, the page should be writable.
+    std::vector<uint8_t> *bitmap;    //bitmap of the total image page, if bit is 1, the page should be writable.
     //the first bit of scetion in the bitmap is bitmap[(rva >> PAGE_SHIFT) / 8] & (1 << ((rva >> PAGE_SHIFT) % 8))
     //if the bitmap is NULL, then no restrict on page attribute.
 } section_info_t;
diff -Nur psw/urts/tcs.cpp psw/urts/tcs.cpp
--- psw/urts/tcs.cpp
+++ psw/urts/tcs.cpp
@@ -102,13 +102,13 @@
 {
     LockGuard lock(&m_thread_mutex);
     //destroy free tcs list
-    for(vector<CTrustThread *>::iterator it=m_free_thread_vector.begin(); it!=m_free_thread_vector.end(); it++)
+    for(std::vector<CTrustThread *>::iterator it=m_free_thread_vector.begin(); it!=m_free_thread_vector.end(); it++)
     {
         delete *it;
     }
     m_free_thread_vector.clear();
     //destroy unallocated tcs list
-    for(vector<CTrustThread *>::iterator it=m_unallocated_threads.begin(); it!=m_unallocated_threads.end(); it++)
+    for(std::vector<CTrustThread *>::iterator it=m_unallocated_threads.begin(); it!=m_unallocated_threads.end(); it++)
     {
         delete *it;
     }
@@ -133,10 +133,10 @@
 
 }
 
-void get_thread_set(vector<se_thread_id_t> &thread_vector);
-inline int CTrustThreadPool::find_thread(vector<se_thread_id_t> &thread_vector, se_thread_id_t thread_id)
+void get_thread_set(std::vector<se_thread_id_t> &thread_vector);
+inline int CTrustThreadPool::find_thread(std::vector<se_thread_id_t> &thread_vector, se_thread_id_t thread_id)
 {
-    for(vector<se_thread_id_t>::iterator it=thread_vector.begin(); it!=thread_vector.end(); it++)
+    for(std::vector<se_thread_id_t>::iterator it=thread_vector.begin(); it!=thread_vector.end(); it++)
         if(*it == thread_id)
             return TRUE;
     return FALSE;
@@ -252,9 +252,9 @@
 {
     LockGuard lock(&m_thread_mutex);
 
-    vector<CTrustThread *> threads;
+    std::vector<CTrustThread *> threads;
 
-    for(vector<CTrustThread *>::iterator it = m_free_thread_vector.begin(); it != m_free_thread_vector.end(); it++)
+    for(std::vector<CTrustThread *>::iterator it = m_free_thread_vector.begin(); it != m_free_thread_vector.end(); it++)
     {
         threads.push_back(*it);
     }
@@ -533,7 +533,7 @@
 
     //if free list is NULL, recycle tcs.
     //get thread id set of current process
-    vector<se_thread_id_t> thread_vector;
+    std::vector<se_thread_id_t> thread_vector;
     get_thread_set(thread_vector);
     //walk through thread cache to see if there is any thread that has exited
     Node<se_thread_id_t, CTrustThread*>* it = m_thread_list, *pre = NULL, *tmp = NULL;
diff -Nur psw/urts/tcs.h psw/urts/tcs.h
--- psw/urts/tcs.h
+++ psw/urts/tcs.h
@@ -41,8 +41,6 @@
 #include <vector>
 #include "node.h"
 
-using namespace std;
-
 typedef int (*bridge_fn_t)(const void*);
 
 class CEnclave;
@@ -88,15 +86,15 @@
     bool is_dynamic_thread_exist();
 protected:
     virtual int garbage_collect() = 0;
-    inline int find_thread(vector<se_thread_id_t> &thread_vector, se_thread_id_t thread_id);
+    inline int find_thread(std::vector<se_thread_id_t> &thread_vector, se_thread_id_t thread_id);
     inline CTrustThread * get_free_thread();
     int bind_thread(const se_thread_id_t thread_id, CTrustThread * const trust_thread);
     void unbind_thread(const se_thread_id_t thread_id);
     CTrustThread * get_bound_thread(const se_thread_id_t thread_id);
     void add_to_free_thread_vector(CTrustThread* it);
     
-    vector<CTrustThread *>                  m_free_thread_vector;
-    vector<CTrustThread *>                  m_unallocated_threads; 
+    std::vector<CTrustThread *>                  m_free_thread_vector;
+    std::vector<CTrustThread *>                  m_unallocated_threads; 
     Node<se_thread_id_t, CTrustThread *>    *m_thread_list;
     Mutex                                   m_thread_mutex; //protect thread_cache list. The mutex is recursive.
                                                             //Thread can operate the list when it get the mutex
diff -Nur sdk/edger8r/linux/Ast.ml sdk/edger8r/linux/Ast.ml
--- sdk/edger8r/linux/Ast.ml
+++ sdk/edger8r/linux/Ast.ml
@@ -142,6 +142,11 @@
   | UnionDef  of struct_def
   | EnumDef   of enum_def
 
+(* List of errno values to translate between host and enclave. *)
+type errno_list_type = {
+  errnos: string list;
+}
+
 (* Function declaration. *)
 type func_decl = {
   fname : string;       (* function name. *)
@@ -158,6 +163,7 @@
   tf_fdecl   : func_decl;
   tf_is_priv : bool;
   tf_is_switchless : bool;
+  tf_is_exception_handler : bool;
 }
 
 type untrusted_func = {
@@ -182,6 +188,7 @@
 type expr =
   | Interface of enclave_func list
   | Composite of composite_type
+  | ErrnoList of errno_list_type
   | Importing of import_decl
   | Include   of string
 
diff -Nur sdk/edger8r/linux/CodeGen.ml sdk/edger8r/linux/CodeGen.ml
--- sdk/edger8r/linux/CodeGen.ml
+++ sdk/edger8r/linux/CodeGen.ml
@@ -46,6 +46,7 @@
   include_list : string list;
   import_exprs : Ast.import_decl list;
   comp_defs    : Ast.composite_type list;
+  errno_list   : Ast.errno_list_type list;
   tfunc_decls  : Ast.trusted_func   list;
   ufunc_decls  : Ast.untrusted_func list;
 }
@@ -75,6 +76,7 @@
     include_list = [];
     import_exprs = [];
     comp_defs    = [];
+    errno_list   = [];
     tfunc_decls  = [];
     ufunc_decls  = []; }
 
@@ -84,6 +86,9 @@
 let is_priv_ecall (tf: Ast.trusted_func) =
   tf.Ast.tf_is_priv
 
+let is_exception_ecall (tf: Ast.trusted_func) =
+  tf.Ast.tf_is_exception_handler
+
 let get_uf_fname (uf: Ast.untrusted_func) =
   uf.Ast.uf_fdecl.Ast.fname
 
@@ -99,6 +104,9 @@
 let tf_list_to_priv_list (tfs: Ast.trusted_func list) =
   List.map is_priv_ecall tfs
 
+let tf_list_to_exception_list (tfs: Ast.trusted_func list) =
+  List.map is_exception_ecall tfs
+
 (* Get a list of names of all private ECALLs *)
 let get_priv_ecall_names (tfs: Ast.trusted_func list) =
   List.filter is_priv_ecall tfs |> List.map get_tf_fname
@@ -118,11 +126,13 @@
   let ac_include_list = ref [] in
   let ac_import_exprs = ref [] in
   let ac_comp_defs = ref [] in
+  let ac_errno_list = ref [] in
   let ac_tfunc_decls = ref [] in
   let ac_ufunc_decls = ref [] in
     List.iter (fun ex ->
       match ex with
           Ast.Composite x -> ac_comp_defs := x :: !ac_comp_defs
+        | Ast.ErrnoList x -> ac_errno_list := x :: !ac_errno_list
         | Ast.Include   x -> ac_include_list := x :: !ac_include_list
         | Ast.Importing x -> ac_import_exprs := x :: !ac_import_exprs
         | Ast.Interface xs ->
@@ -138,6 +148,7 @@
       include_list = List.rev !ac_include_list;
       import_exprs = List.rev !ac_import_exprs;
       comp_defs    = List.rev !ac_comp_defs;
+      errno_list   = List.rev !ac_errno_list;
       tfunc_decls  = List.rev !ac_tfunc_decls;
       ufunc_decls  = List.rev !ac_ufunc_decls; }
 
@@ -335,6 +346,62 @@
       | Ast.UnionDef  u -> mk_union_decl  (gen_member_list u.Ast.mlist) u.Ast.sname
       | Ast.EnumDef   e -> mk_enum_def    e
 
+(* Generate the internal errno enum definition. *)
+let gen_errno_enum (el: Ast.errno_list_type list) =
+  let all_errnos = List.fold_left (fun acc l -> acc @ l.Ast.errnos) [] el
+  in
+  let all_sorted = List.sort_uniq compare all_errnos
+  in
+  let errno_list = List.fold_left (fun acc name ->
+                                    acc ^ "\tSGX_ERRNO_" ^ name ^ ",\n")
+                                  "" all_sorted
+  in
+    if all_errnos = [] then "" else
+      sprintf "enum _sgx_errno_bridge_t {\n%s} sgx_errno_bridge_t;\n" errno_list
+
+(* Generate the function to convert errno values to the internal enum. *)
+let gen_errno_to_conv (el: Ast.errno_list_type list) =
+  let all_errnos = List.fold_left (fun acc l -> acc @ l.Ast.errnos) [] el
+  in
+  let all_sorted = List.sort_uniq compare all_errnos
+  in
+  let errno_switch =
+    "\tswitch(value)\n\t{\n" ^
+    List.fold_left (fun acc name ->
+                     acc ^ "\t\tcase " ^ name ^
+                     ":\n\t\t\tvalue = SGX_ERRNO_" ^ name ^
+                     ";\n\t\t\tbreak;\n")
+                   "" all_sorted ^
+    "\t\tdefault:\n\t\t\tvalue |= 0x8000;\n\t\t\tbreak;\n\t}\n"
+    (* The above 0x8000 serves two purposes
+     * 1. Ensures that no host errno values can colide with our enum.
+     *  * Assumes < 32k errno values in enum.
+     * 2. Provides a debugging aide to indicate that errno is host-relative.
+     *)
+  in
+    if all_errnos = [] then "" else
+      sprintf "static int bridge_translate_errno_to_internal(int value)\n{\n%s\
+        \treturn value;\n}\n" errno_switch
+
+(* Generate the function to convert errno values from the internal enum. *)
+let gen_errno_from_conv (el: Ast.errno_list_type list) =
+  let all_errnos = List.fold_left (fun acc l -> acc @ l.Ast.errnos) [] el
+  in
+  let all_sorted = List.sort_uniq compare all_errnos
+  in
+  let errno_switch =
+    "\tswitch(value)\n\t{\n" ^
+    List.fold_left (fun acc name ->
+                      acc ^ "\t\tcase SGX_ERRNO_" ^ name ^
+                      ":\n\t\t\tvalue = " ^ name ^
+                      ";\n\t\t\tbreak;\n")
+                    "" all_sorted ^
+    "\t}\n"
+  in
+    if all_errnos = [] then "" else
+      sprintf "static int bridge_translate_errno_from_internal(int value)\n{\n%s\
+        \treturn value;\n}\n" errno_switch
+
 (* Generate a list of '#include' *)
 let gen_include_list (xs: string list) =
   List.fold_left (fun acc s -> acc ^ sprintf "#include \"%s\"\n" s) "" xs
@@ -391,15 +458,23 @@
 
 (* ---------------------------------------------------------------------- *)
 
+let fold_left3 f arg a b c =
+  let rec loop arg = function
+    | x::xs, y::ys, z::zs -> loop(f arg x y z) (xs, ys, zs)
+    | [], [], [] -> arg
+  in
+  loop arg (a, b, c)
+
 (* `gen_ecall_table' is used to generate ECALL table with the following form:
     SGX_EXTERNC const struct {
        size_t nr_ecall;    /* number of ECALLs */
        struct {
            void   *ecall_addr;
            uint8_t is_priv;
+           uint8_t is_exception;
        } ecall_table [nr_ecall];
    } g_ecall_table = {
-       2, { {sgx_foo, 1}, {sgx_bar, 0} }
+       2, { {sgx_foo, 1, 0}, {sgx_bar, 0, 1} }
    };
 *)
 let gen_ecall_table (tfs: Ast.trusted_func list) =
@@ -407,18 +482,19 @@
   let ecall_table_size = List.length tfs in
   let trusted_fds = tf_list_to_fd_list tfs in
   let priv_bits = tf_list_to_priv_list tfs in
+  let exception_bits = tf_list_to_exception_list tfs in
   let tbridge_names = List.map (fun (fd: Ast.func_decl) ->
                                   mk_tbridge_name fd.Ast.fname) trusted_fds in
   let ecall_table =
     let bool_to_int b = if b then 1 else 0 in
     let inner_table =
-      List.fold_left2 (fun acc s b ->
-        sprintf "%s\t\t{(void*)(uintptr_t)%s, %d},\n" acc s (bool_to_int b)) "" tbridge_names priv_bits
+      fold_left3 (fun acc s is_priv is_exception_handler ->
+        sprintf "%s\t\t{(void*)(uintptr_t)%s, %d, %d},\n" acc s (bool_to_int is_priv) (bool_to_int is_exception_handler)) "" tbridge_names priv_bits exception_bits
     in "\t{\n" ^ inner_table ^ "\t}\n"
   in
     sprintf "SGX_EXTERNC const struct {\n\
 \tsize_t nr_ecall;\n\
-\tstruct {void* ecall_addr; uint8_t is_priv;} ecall_table[%d];\n\
+\tstruct {void* ecall_addr; uint8_t is_priv; uint8_t is_exception;} ecall_table[%d];\n\
 } %s = {\n\
 \t%d,\n\
 %s};\n" ecall_table_size
@@ -676,12 +752,18 @@
                                acc ^ ", " ^ mk_parm_name pty dlr) p0 ps)
 
 (* Generate untrusted bridge code for a given untrusted function. *)
-let gen_func_ubridge (file_shortnm: string) (ufunc: Ast.untrusted_func) =
+let gen_func_ubridge (file_shortnm: string) (ufunc: Ast.untrusted_func) (conv_errno: bool) =
   let fd = ufunc.Ast.uf_fdecl in
   let propagate_errno = ufunc.Ast.uf_propagate_errno in
   let func_open = sprintf "%s\n{\n" (mk_ubridge_proto file_shortnm fd.Ast.fname) in
   let func_close = "\treturn SGX_SUCCESS;\n}\n" in
-  let set_errno = if propagate_errno then "\tms->ocall_errno = errno;" else "" in
+  let set_errno =
+    if propagate_errno then "\tms->ocall_errno = " ^
+      if conv_errno then
+        "bridge_translate_errno_to_internal(errno);"
+      else
+        "errno;"
+    else "" in
   let ms_struct_name = mk_ms_struct_name fd.Ast.fname in
   let declare_ms_ptr = sprintf "%s* %s = SGX_CAST(%s*, %s);"
                                ms_struct_name
@@ -1345,7 +1427,7 @@
      List.fold_left (fun acc s -> acc ^ s) s2 do_gen_ocalloc_block
   
 (* Generate trusted proxy code for a given untrusted function. *)
-let gen_func_tproxy (ufunc: Ast.untrusted_func) (idx: int) =
+let gen_func_tproxy (ufunc: Ast.untrusted_func) (idx: int) (conv_errno: bool) =
   let fd = ufunc.Ast.uf_fdecl in
   let propagate_errno = ufunc.Ast.uf_propagate_errno in
   let func_open = sprintf "%s\n{\n" (gen_tproxy_proto fd) in
@@ -1395,7 +1477,13 @@
                              Ast.PTVal _ -> acc
                | Ast.PTPtr(ty, attr) -> acc ^ copy_memory attr declr) "" plist in
 
-  let set_errno = if propagate_errno then "\t\terrno = ms->ocall_errno;\n" else "" in
+  let set_errno =
+    if propagate_errno then "\terrno = " ^
+      if conv_errno then
+        "bridge_translate_errno_from_internal(ms->ocall_errno);"
+      else
+        "ms->ocall_errno;"
+    else "" in
   let func_close = sprintf "%s%s%s\n%s%s\n"
                            (handle_out_ptr fd.Ast.plist)
                            set_errno
@@ -1455,12 +1543,16 @@
       ec.tfunc_decls
       (Util.mk_seq 0 (List.length ec.tfunc_decls - 1))
   in
+  let errno_enum = gen_errno_enum ec.errno_list in
+  let errno_conv = gen_errno_to_conv ec.errno_list in
   let ubridge_list =
-    List.map (fun fd -> gen_func_ubridge ec.file_shortnm fd)
+    List.map (fun fd -> gen_func_ubridge ec.file_shortnm fd (errno_enum <> ""))
       (ec.ufunc_decls) in
   let out_chan = open_out code_fname in
     output_string out_chan (include_hd ^ include_errno ^ "\n");
     ms_writer out_chan ec;
+    output_string out_chan (errno_enum ^ "\n");
+    output_string out_chan (errno_conv ^ "\n");
     List.iter (fun s -> output_string out_chan (s ^ "\n")) ubridge_list;
     output_string out_chan (gen_ocall_table ec);
     List.iter (fun s -> output_string out_chan (s ^ "\n")) uproxy_list;
@@ -1492,14 +1584,18 @@
     List.map (fun tfd -> gen_func_tbridge tfd dummy_var) trusted_fds in
   let ecall_table = gen_ecall_table ec.tfunc_decls in
   let entry_table = gen_entry_table ec in
+  let errno_enum = gen_errno_enum ec.errno_list in
+  let errno_conv = gen_errno_from_conv ec.errno_list in
   let tproxy_list = List.map2
-                      (fun fd idx -> gen_func_tproxy fd idx)
+                      (fun fd idx -> gen_func_tproxy fd idx (errno_enum <> ""))
                       (ec.ufunc_decls)
                       (Util.mk_seq 0 (List.length ec.ufunc_decls - 1)) in
   let out_chan = open_out code_fname in
     output_string out_chan (include_hd ^ "\n");
     ms_writer out_chan ec;
     List.iter (fun s -> output_string out_chan (s ^ "\n")) tbridge_list;
+    output_string out_chan (errno_enum ^ "\n");
+    output_string out_chan (errno_conv ^ "\n");
     output_string out_chan (ecall_table ^ "\n");
     output_string out_chan (entry_table ^ "\n");
     output_string out_chan "\n";
@@ -1603,9 +1699,10 @@
     List.iter check_ecall priv_ecall_names
 
 (* Check that there is at least one public ECALL function. *)
-let check_priv_funcs (ec: enclave_content) =
+let check_priv_and_exception_funcs (ec: enclave_content) =
   let priv_bits = tf_list_to_priv_list ec.tfunc_decls in
-  if List.for_all (fun is_priv -> is_priv) priv_bits
+  let exception_bits = tf_list_to_exception_list ec.tfunc_decls in
+  if List.for_all2 (fun is_priv is_exception_handler -> is_priv || is_exception_handler) priv_bits exception_bits
   then failwithf "the enclave `%s' contains no public root ECALL.\n" ec.file_shortnm
   else report_orphaned_priv_ecall ec
 
@@ -1620,7 +1717,7 @@
  *)
 let reduce_import (ec: enclave_content) =
   (* Append a EDL list to another. Keep the first element and replace the
-   second one with empty element contains functions not in the first one 
+   second one with empty element contains functions not in the first one
    if both lists contain a same EDL. The function sequence is backwards compatible.*)
   let join (ec1: enclave_content list) (ec2: enclave_content list) =
     let join_one (acc: enclave_content list) (ec: enclave_content) =
@@ -1698,6 +1795,7 @@
         include_list = acc.include_list @ ec2.include_list;
         import_exprs = [];
         comp_defs    = acc.comp_defs   @ ec2.comp_defs;
+        errno_list   = acc.errno_list  @ ec2.errno_list;
         tfunc_decls  = acc.tfunc_decls @ ec2.tfunc_decls;
         ufunc_decls  = acc.ufunc_decls @ ec2.ufunc_decls; }
   in
@@ -1713,6 +1811,6 @@
     create_dir ep.trusted_dir;
     check_duplication ec;
     check_allow_list ec;
-    (if not ep.header_only then check_priv_funcs ec);
+    (if not ep.header_only then check_priv_and_exception_funcs ec);
     (if ep.gen_untrusted then (gen_untrusted_header ec; if not ep.header_only then gen_untrusted_source ec));
     (if ep.gen_trusted then (gen_trusted_header ec; if not ep.header_only then gen_trusted_source ec))
diff -Nur sdk/edger8r/linux/Lexer.mll sdk/edger8r/linux/Lexer.mll
--- sdk/edger8r/linux/Lexer.mll
+++ sdk/edger8r/linux/Lexer.mll
@@ -79,6 +79,8 @@
   | "struct"     { Tstruct }
   | "union"      { Tunion }
   | "enum"       { Tenum }
+  | "errno_list" { Terrno_list }
+  | "exception_handler" { Texception_handler }
 
   (* specifier *)
   | "enclave"    { Tenclave }
diff -Nur sdk/edger8r/linux/Parser.mly sdk/edger8r/linux/Parser.mly
--- sdk/edger8r/linux/Parser.mly
+++ sdk/edger8r/linux/Parser.mly
@@ -305,7 +305,7 @@
 %token Tchar Tshort Tunsigned Tint Tfloat Tdouble
        Tint8 Tint16 Tint32 Tint64
        Tuint8 Tuint16 Tuint32 Tuint64
-       Tsizet Twchar Tvoid Tlong Tstruct Tunion Tenum
+       Tsizet Twchar Tvoid Tlong Tstruct Tunion Tenum Terrno_list Texception_handler
 %token Tenclave Tfrom Timport Ttrusted Tuntrusted Tallow Tpropagate_errno
 
 %start start_parsing
@@ -529,6 +529,19 @@
   | enum_definition                   { $1 }
   ;
 
+errno_list: Terrno_list TLBrace errno_list_body TRBrace {
+      { Ast.errnos = $3; }
+    }
+  ;
+
+errno_list_body: /* empty */ { [] }
+  | errno_list_eles          { List.rev $1 }
+  ;
+
+errno_list_eles: Tidentifier           { [$1] }
+  | errno_list_eles TComma Tidentifier { $3 :: $1 }
+  ;
+
 member_list: member_def TSemicolon    { [$1] }
   | member_list member_def TSemicolon { $2 :: $1 }
   ;
@@ -591,10 +604,15 @@
   | Tswitchless                      { true  }
   ;
 
+/* is_exception_handler? Default to false */
+exception_handler: /* nothing */ { false }
+  | Texception_handler           { true }
+  ;
+
 trusted_functions: /* nothing */          { [] }
-  | trusted_functions access_modifier func_def switchless_annotation TSemicolon {
-      check_ptr_attr $3 (symbol_start_pos(), symbol_end_pos());
-      Ast.Trusted { Ast.tf_fdecl = $3; Ast.tf_is_priv = $2; Ast.tf_is_switchless = $4 } :: $1
+  | trusted_functions exception_handler access_modifier func_def switchless_annotation TSemicolon {
+      check_ptr_attr $4 (symbol_start_pos(), symbol_end_pos());
+      Ast.Trusted { Ast.tf_fdecl = $4; Ast.tf_is_priv = $3; Ast.tf_is_switchless = $5; Ast.tf_is_exception_handler = $2; } :: $1
     }
   ;
 
@@ -661,6 +679,7 @@
   | expressions include_declaration           { Ast.Include($2)   :: $1 }
   | expressions import_declaration TSemicolon { Ast.Importing($2) :: $1 }
   | expressions composite_defs TSemicolon     { Ast.Composite($2) :: $1 }
+  | expressions errno_list TSemicolon         { Ast.ErrnoList($2) :: $1 }
   | expressions enclave_functions             { Ast.Interface($2) :: $1 }
   ;
 
diff -Nur sdk/sign_tool/SignTool/elf_helper.h sdk/sign_tool/SignTool/elf_helper.h
--- sdk/sign_tool/SignTool/elf_helper.h
+++ sdk/sign_tool/SignTool/elf_helper.h
@@ -41,11 +41,10 @@
 
 static void dump_textrel(const uint64_t& offset)
 {
-    using namespace std;
 
-    cerr << "warning: TEXTRELs found at offset: "
-         << hex << showbase     /* show the '0x' prefix */
-         << offset << endl;
+    std::cerr << "warning: TEXTRELs found at offset: "
+              << std::hex << std::showbase     /* show the '0x' prefix */
+              << offset << std::endl;
 }
 
 template <int N>
@@ -87,13 +86,13 @@
 
     static bool dump_textrels(BinParser *bp)
     {
-        vector<uint64_t> offsets;
+        std::vector<uint64_t> offsets;
         bool no_rel = true;
         /* The dynamic_cast<> shouldn't fail. */
         elf_parser_t   * p = dynamic_cast<elf_parser_t*>(bp);
         if (p == NULL)
             return no_rel;
-        vector<const char *> sec_names;
+        std::vector<const char *> sec_names;
         p->get_executable_sections(sec_names);
         /* Warn user of TEXTRELs */
         for (unsigned i = 0; i< sec_names.size(); i++)
diff -Nur sdk/sign_tool/SignTool/manage_metadata.cpp sdk/sign_tool/SignTool/manage_metadata.cpp
--- sdk/sign_tool/SignTool/manage_metadata.cpp
+++ sdk/sign_tool/SignTool/manage_metadata.cpp
@@ -55,7 +55,11 @@
 #include <iomanip>
 #include <fstream>
 
-using namespace tinyxml2;
+using tinyxml2::XML_ERROR_FILE_COULD_NOT_BE_OPENED;
+using tinyxml2::XML_ERROR_FILE_NOT_FOUND;
+using tinyxml2::XML_SUCCESS;
+using tinyxml2::XMLElement;
+using tinyxml2::XMLError;
 
 #define ALIGN_SIZE 0x1000
 
@@ -227,9 +231,9 @@
     if(timeinfo  == NULL)
         return false;
     uint32_t tmp_date = (timeinfo->tm_year+1900)*10000 + (timeinfo->tm_mon+1)*100 + timeinfo->tm_mday;
-    stringstream ss;
+    std::stringstream ss;
     ss<<"0x"<<tmp_date;
-    ss>>hex>>tmp_date;
+    ss>>std::hex>>tmp_date;
     *date = tmp_date;
     return true;
 }
@@ -513,7 +517,7 @@
     guard_page.entry.id = LAYOUT_ID_GUARD;
     guard_page.entry.page_count = SE_GUARD_PAGE_SIZE >> SE_PAGE_SHIFT;
 
-    vector<layout_t> thread_layouts;
+    std::vector<layout_t> thread_layouts;
     // heap
     layout.entry.id = LAYOUT_ID_HEAP_MIN;
     layout.entry.page_count = (uint32_t)(m_create_param.heap_min_size >> SE_PAGE_SHIFT);
@@ -702,7 +706,7 @@
     }
     return true;
 }
-bool CMetadata::build_patch_entries(vector<patch_entry_t> &patches)
+bool CMetadata::build_patch_entries(std::vector<patch_entry_t> &patches)
 {
     uint32_t size = (uint32_t)(patches.size() * sizeof(patch_entry_t));
     patch_entry_t *patch_table = (patch_entry_t *) alloc_buffer_from_metadata(size);
@@ -724,7 +728,7 @@
 bool CMetadata::build_patch_table()
 {
     const uint8_t *base_addr = (const uint8_t *)m_parser->get_start_addr();
-    vector<patch_entry_t> patches;
+    std::vector<patch_entry_t> patches;
     patch_entry_t patch;
     memset(&patch, 0, sizeof(patch));
 
diff -Nur sdk/sign_tool/SignTool/manage_metadata.h sdk/sign_tool/SignTool/manage_metadata.h
--- sdk/sign_tool/SignTool/manage_metadata.h
+++ sdk/sign_tool/SignTool/manage_metadata.h
@@ -100,7 +100,7 @@
     bool build_patch_table();
     bool update_layout_entries();
     bool build_layout_entries();
-    bool build_patch_entries(vector<patch_entry_t> &patches);
+    bool build_patch_entries(std::vector<patch_entry_t> &patches);
 
     layout_entry_t *get_entry_by_id(uint16_t id);
     bool build_tcs_template(tcs_t *tcs);
@@ -113,7 +113,7 @@
     metadata_t *m_metadata;
     BinParser *m_parser;
     create_param_t m_create_param;
-    vector <layout_t> m_layouts;
+    std::vector <layout_t> m_layouts;
     uint64_t m_rva;
     uint32_t m_gd_size;
     uint8_t *m_gd_template;
diff -Nur sdk/simulation/assembly/lowlib.h sdk/simulation/assembly/lowlib.h
--- sdk/simulation/assembly/lowlib.h
+++ sdk/simulation/assembly/lowlib.h
@@ -40,6 +40,15 @@
 
 #include <stdint.h>
 
+#if defined(__GNUC__) && !defined(__clang__)
+#define LOAD_REGS_ATTRIBUTES \
+  __attribute__((optimize("-O0,-fno-omit-frame-pointer")))
+#elif defined(__clang__)
+#define LOAD_REGS_ATTRIBUTES [[clang::optnone]]
+#else
+#pragma warning "Unsupported compiler for per-function deoptimization"
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
diff -Nur sdk/simulation/SEConfigureCPUSVN/linux/config_cpusvn.cpp sdk/simulation/SEConfigureCPUSVN/linux/config_cpusvn.cpp
--- sdk/simulation/SEConfigureCPUSVN/linux/config_cpusvn.cpp
+++ sdk/simulation/SEConfigureCPUSVN/linux/config_cpusvn.cpp
@@ -49,13 +49,11 @@
 #include <string>
 #include <sstream>
 
-using namespace std;
-
 static void convert_cpusvn_to_string(sgx_cpu_svn_t &cpusvn, string &str)
 {
     uint32_t buffer[4];
     memcpy_s(&buffer, sizeof(uint32_t)*4, &cpusvn, sizeof(sgx_cpu_svn_t));
-    stringstream ss;
+    std::stringstream ss;
     for(int i=0; i<4; i++)
     {
         buffer[i] = __builtin_bswap32(buffer[i]);
diff -Nur sdk/simulation/tinst/t_instructions.cpp sdk/simulation/tinst/t_instructions.cpp
--- sdk/simulation/tinst/t_instructions.cpp
+++ sdk/simulation/tinst/t_instructions.cpp
@@ -286,6 +286,8 @@
 static void
 _EEXIT(uintptr_t dest, uintptr_t xcx, uintptr_t xdx, uintptr_t xsi, uintptr_t xdi) __attribute__((section(".nipx")));
 
+// The call to load_regs assumes the existence of a frame pointer.
+LOAD_REGS_ATTRIBUTES
 static void
 _EEXIT(uintptr_t dest, uintptr_t xcx, uintptr_t xdx, uintptr_t xsi, uintptr_t xdi)
 {
@@ -323,9 +325,6 @@
 
 // Master entry functions
 
-#pragma GCC push_options
-#pragma GCC optimize ("O0")
-
 uintptr_t _SE3(uintptr_t xax, uintptr_t xbx, uintptr_t xcx,
                uintptr_t xdx, uintptr_t xsi, uintptr_t xdi)
 {
@@ -350,5 +349,3 @@
     GP();
     return (uintptr_t)-1;
 }
-
-#pragma GCC pop_options
diff -Nur sdk/simulation/uae_service_sim/linux/platform_service_sim.cpp sdk/simulation/uae_service_sim/linux/platform_service_sim.cpp
--- sdk/simulation/uae_service_sim/linux/platform_service_sim.cpp
+++ sdk/simulation/uae_service_sim/linux/platform_service_sim.cpp
@@ -37,7 +37,9 @@
 #include <sys/types.h>
 #include <stdlib.h>
 #include <pwd.h>
+#ifndef __STDC_FORMAT_MACROS
 #define __STDC_FORMAT_MACROS
+#endif
 #include <inttypes.h>
 
 static Mutex g_pse_sim_lock;
diff -Nur sdk/simulation/uinst/u_instructions.cpp sdk/simulation/uinst/u_instructions.cpp
--- sdk/simulation/uinst/u_instructions.cpp
+++ sdk/simulation/uinst/u_instructions.cpp
@@ -209,6 +209,7 @@
 // Master entry functions
 
 
+LOAD_REGS_ATTRIBUTES
 void _SE3(uintptr_t xax, uintptr_t xbx,
           uintptr_t xcx, uintptr_t xdx,
           uintptr_t xsi, uintptr_t xdi)
diff -Nur sdk/simulation/urtssim/get_state.cpp sdk/simulation/urtssim/get_state.cpp
--- sdk/simulation/urtssim/get_state.cpp
+++ sdk/simulation/urtssim/get_state.cpp
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2011-2017 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+#include "td_mngr.h"
+
+extern "C" int is_tcs_sim_active(const tcs_t *tcs)
+{
+  if (tcs)
+  {
+    tcs_sim_t* tcs_sim = (tcs_sim_t*)(tcs->reserved);
+    if (tcs_sim)
+      return (tcs_sim->tcs_state == TCS_STATE_ACTIVE ? 1 : 0);
+  }
+  return 0;
+}
diff -Nur sdk/tlibc/gen/spinlock.c sdk/tlibc/gen/spinlock.c
--- sdk/tlibc/gen/spinlock.c
+++ sdk/tlibc/gen/spinlock.c
@@ -34,7 +34,7 @@
 static inline void _mm_pause(void) __attribute__((always_inline));
 static inline int _InterlockedExchange(int volatile * dst, int val) __attribute__((always_inline));
 
-static inline void _mm_pause(void)
+static inline void _mm_pause(void)  /* definition requires -ffreestanding */
 {
     __asm __volatile(
         "pause"
diff -Nur sdk/tlibc/string/memset_s.c sdk/tlibc/string/memset_s.c
--- sdk/tlibc/string/memset_s.c
+++ sdk/tlibc/string/memset_s.c
@@ -37,6 +37,7 @@
 #include <errno.h>
 #include <stdint.h>
 #include <string.h>
+#include "rts_config.h"
 
 /*
  * __memset_vp is a volatile pointer to a function.
diff -Nur sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp
--- sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp
+++ sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp
@@ -35,6 +35,7 @@
 #include "se_tcrypto_common.h"
 #include "openssl/cmac.h"
 #include "openssl/err.h"
+#include "openssl/evp.h"
 
 /* Message Authentication - Rijndael 128 CMAC
 * Parameters:
diff -Nur sdk/trts/init_enclave.cpp sdk/trts/init_enclave.cpp
--- sdk/trts/init_enclave.cpp
+++ sdk/trts/init_enclave.cpp
@@ -47,6 +47,7 @@
 #include "trts_internal.h"
 #include "linux/elf_parser.h"
 #include "rts.h"
+#include "rts_config.h"
 #include "trts_util.h"
 #include "se_memcpy.h"
 
@@ -197,7 +198,7 @@
     else
 #endif
     {
-        memset_s(GET_PTR(void, enclave_base, g_global_data.heap_offset), g_global_data.heap_size, 0, g_global_data.heap_size);
+        // memset_s(GET_PTR(void, enclave_base, g_global_data.heap_offset), g_global_data.heap_size, 0, g_global_data.heap_size);
     }
 
     g_enclave_state = ENCLAVE_INIT_DONE;
diff -Nur sdk/trts/linux/x86_64/setcontext.S sdk/trts/linux/x86_64/setcontext.S
--- sdk/trts/linux/x86_64/setcontext.S
+++ sdk/trts/linux/x86_64/setcontext.S
@@ -24,12 +24,17 @@
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
+#define __NR_rt_sigprocmask 0
+#ifndef __linux__
+#define __linux__
+#endif
+
 #include "ucontext_i.h"
 #if (!ISE)
 #if defined __linux__
-#include <asm/unistd.h>
+//#include <asm/unistd.h>
 #define	SIG_SETMASK   2
-#define	SIGSET_BYTE_SIZE   (64/8)
+#define	SIGSET_BYTE_SIZE   8
 #elif defined __FreeBSD__
 #include <sys/syscall.h>
 #endif
diff -Nur sdk/trts/trts.cpp sdk/trts/trts.cpp
--- sdk/trts/trts.cpp
+++ sdk/trts/trts.cpp
@@ -39,6 +39,7 @@
 #include "global_data.h"
 #include "trts_internal.h"
 #include "internal/rts.h"
+#include "rts_config.h"
 
 #ifdef SE_SIM
 #include "t_instructions.h"    /* for `g_global_data_sim' */
diff -Nur sdk/trts/trts_ecall.cpp sdk/trts/trts_ecall.cpp
--- sdk/trts/trts_ecall.cpp
+++ sdk/trts/trts_ecall.cpp
@@ -66,6 +66,11 @@
             return SGX_ERROR_ECALL_NOT_ALLOWED;
         return SGX_SUCCESS;
     }
+    // Exception handlers should be allowed no matter what ocall status it is.
+    if (g_ecall_table.ecall_table[ordinal].is_exception)
+    {
+      return SGX_SUCCESS;
+    }
     ocall_context_t *context = reinterpret_cast<ocall_context_t*>(thread_data->last_sp);
     if(context->ocall_flag != OCALL_FLAG)
     {
@@ -339,7 +344,7 @@
     return SGX_SUCCESS;
 }
 
-sgx_status_t do_ecall(int index, void *ms, void *tcs)
+sgx_status_t do_ecall(int index, void *ms, void *tcs, bool interrupted)
 {
     sgx_status_t status = SGX_ERROR_UNEXPECTED;
     if(ENCLAVE_INIT_DONE != get_enclave_state())
@@ -347,7 +352,9 @@
         return status;
     }
     thread_data_t *thread_data = get_thread_data();
-    if( (NULL == thread_data) || ((thread_data->stack_base_addr == thread_data->last_sp) && (0 != g_global_data.thread_policy)))
+    // The thread local storage should not be cleared if this is a signal
+    // handling ecall that interrupts the original ecall.
+    if(!interrupted && ((NULL == thread_data) || ((thread_data->stack_base_addr == thread_data->last_sp) && (0 != g_global_data.thread_policy))))
     {
         status = do_init_thread(tcs, false);
         if(0 != status)
diff -Nur sdk/trts/trts_internal.h sdk/trts/trts_internal.h
--- sdk/trts/trts_internal.h
+++ sdk/trts/trts_internal.h
@@ -40,6 +40,7 @@
 typedef struct {
     const void     *ecall_addr;
     uint8_t         is_priv;
+    uint8_t         is_exception;
 } ecall_addr_t;
 
 typedef struct {
@@ -66,7 +67,10 @@
 
 sgx_status_t do_init_thread(void *tcs, bool enclave_init);
 sgx_status_t do_init_enclave(void *ms, void *tcs) __attribute__((section(".nipx")));
-sgx_status_t do_ecall(int index, void *ms, void *tcs);
+// If |interrupted| is true, this is a user defined exception handler ecall
+// which interrupts the current running ecall, while trts_handle_exception deals
+// with the sgx defined exceptions.
+sgx_status_t do_ecall(int index, void *ms, void *tcs, bool interrupted);
 sgx_status_t do_oret(void *ms);
 sgx_status_t trts_handle_exception(void *tcs);
 sgx_status_t do_ecall_add_thread(void *ms);
diff -Nur sdk/trts/trts_nsp.cpp sdk/trts/trts_nsp.cpp
--- sdk/trts/trts_nsp.cpp
+++ sdk/trts/trts_nsp.cpp
@@ -48,7 +48,8 @@
 #include "trts_internal.h"
 #include "internal/rts.h"
 
-static void init_stack_guard(void *tcs)
+static void __attribute__((optimize("no-stack-protector")))
+init_stack_guard(void *tcs)
 {
     thread_data_t *thread_data = get_thread_data();
     if( (NULL == thread_data) || ((thread_data->stack_base_addr == thread_data->last_sp) && (0 != g_global_data.thread_policy)))
@@ -87,13 +88,24 @@
         return error;
     }
 
-    if(cssa == 0)
-    {
+    // Check whether the incoming ecall is a user exception. If index is within
+    // range of the ecall table size, the is_exception field will be true for
+    // user exceptions.
+    uint8_t is_user_exception =
+        (index >= 0 && index < int(g_ecall_table.nr_ecall)) &&
+        g_ecall_table.ecall_table[index].is_exception;
+    // For a user exception, call |do_ecall| to enter enclave and handle the
+    // signal, in this case cssa could be 0 or 1 (which is likely to be 1 when
+    // an enclave is interrupted by an exception).
+    if(cssa == 0 || (is_user_exception && cssa == 1))    {
         if((index >= 0) || (index == ECMD_INIT_SWITCHLESS) || (index == ECMD_RUN_SWITCHLESS_TWORKER))
         {
             // Initialize stack guard if necessary
             init_stack_guard(tcs);
-            error = do_ecall(index, ms, tcs);
+            // If |cssa| is non-zero, this ecall is entering enclave as a user
+            // exception that interrupts the current running ecall.
+            bool is_interrupted = cssa != 0;
+            error = do_ecall(index, ms, tcs, is_interrupted);
         }
         else if(index == ECMD_INIT_ENCLAVE)
         {
diff -Nur sdk/trts/trts_shared_constants.h sdk/trts/trts_shared_constants.h
--- sdk/trts/trts_shared_constants.h
+++ sdk/trts/trts_shared_constants.h
@@ -47,7 +47,7 @@
 #endif
 
 
-#define STATIC_STACK_SIZE   688
+#define STATIC_STACK_SIZE   (8 * 1024)
 
 
 #endif
--- /dev/null
+++ BUILD
@@ -0,0 +1,1111 @@
+# linux-sgx is the Intel SGX SDK
+
+package(
+    default_visibility = ["//visibility:public"],
+)
+
+# "notice" licenses present:
+# BSD (Intel SGX SDK, libunwind, libcxxrt),
+# NetBSD, FreeBSD, OpenBSD
+# zlib/libpng (Tinyxml)
+# UIUC (LLVM's compiler_rt library)
+# Apache v2 (EPID SDK)
+# STLPort
+# OpenSSL/SSLeay* (OpenSSL),
+
+# "reciprocal" licenses mentioned but unused:
+# Eclipse public license 1.0 (SGX Eclipse plugin)
+
+# "restricted" licenses present:
+# GPLv2 (ittnotify)
+
+# "restricted" licenses mentioned but unused:
+# Intel (precompiled signed enclaves),
+# Intel sample code license (rdrand)
+
+# "unencumbered" licenses present:
+# SQLite
+# CC0 1.0 (DLMalloc),
+licenses(["reciprocal"])  # Eclipse public license
+
+exports_files([
+    "LICENSE",
+    "enclave_sim.lds",
+    "enclave_test_private.pem",
+])
+
+load(
+    ":sgx_sdk.bzl",
+    "sgx_enclave",
+    "sgx_enclave_configuration",
+)
+
+config_setting(
+    name = "dbg",
+    values = {
+        "compilation_mode": "dbg",
+    },
+)
+
+sgx_enclave_configuration(name = "enclave_debug_config")
+
+
+proto_library(
+    name = "ipc_common_proto",
+    srcs = ["psw/ae/common/proto/messages.proto"],
+)
+cc_proto_library(
+    name = "ipc_common_proto_cc",
+    deps = [":ipc_common_proto"],
+)
+
+SL_COMMON_SRCS = [
+    "common/src/sl_fcall_mngr_common.c",
+    "common/src/sl_siglines_common.c",
+]
+
+RTS_COMMON_SRCS = [
+    "common/src/linux/xsave_gnu.S",
+]
+
+SL_COMMON_HDRS = [
+    # Headers for switchless calls that must be copied to reinterpret with or
+    # without -DSL_INSIDE_ENCLAVE.
+    "common/inc/internal/sl_uswitchless.h",
+    "common/inc/internal/sl_workers.h",
+    "common/inc/internal/sl_fcall_mngr.h",
+    "common/inc/internal/sl_fcall_mngr_common.h",  # depends of sl_fcall_mngr.h
+    "common/inc/internal/sl_debug.h",
+    "common/inc/internal/sl_siglines.h",
+]
+
+RTS_COMMON_TEXTUAL_HDRS = [
+    "common/inc/internal/linux/linux-regs.h",  # included as ASM
+]
+
+URTS_COMMON_SRCS = RTS_COMMON_SRCS + [
+    "common/src/sgx_memset_s.cpp",
+    "psw/urts/cpu_features.cpp",
+    "psw/urts/enclave.cpp",
+    "psw/urts/enclave_mutex.cpp",
+    "psw/urts/launch_checker.cpp",
+    "psw/urts/linux/debugger_support.cpp",
+    "psw/urts/linux/enter_enclave.S",
+    "psw/urts/linux/edmm_utility.cpp",
+    "psw/urts/linux/get_thread_id.cpp",
+    "psw/urts/linux/misc.cpp",
+    "psw/urts/linux/sig_handler.cpp",
+    "psw/urts/linux/urts.cpp",
+    "psw/urts/linux/urts_emodpr.cpp",
+    "psw/urts/linux/urts_internal.cpp",
+    "psw/urts/linux/urts_trim.cpp",
+    "psw/urts/loader.cpp",
+    "psw/urts/node.cpp",
+    "psw/urts/parser/elf32parser.cpp",
+    "psw/urts/parser/elf64parser.cpp",
+    "psw/urts/parser/parserfactory.cpp",
+    "psw/urts/parser/section.cpp",
+    "psw/urts/prd_css_util.cpp",
+    "psw/urts/routine.cpp",
+    "psw/urts/se_detect.cpp",
+    "psw/urts/se_ocalls.cpp",
+    "psw/urts/tcs.cpp",
+    "psw/urts/urts_version.cpp",
+    "psw/urts/urts_xsave.cpp",
+]
+
+URTS_COMMON_HDRS = [
+    "common/inc/internal/enclave_creator.h",
+    "psw/urts/cpu_features.h",
+    "psw/urts/create_param.h",
+    "psw/urts/enclave.h",
+    "psw/urts/enclave_creator_hw.h",
+    "psw/urts/file.h",
+    "psw/urts/launch_checker.h",
+    "psw/urts/linux/debugger_support.h",
+    "psw/urts/linux/edmm_utility.h",
+    "psw/urts/linux/read_xcr0.h",
+    "psw/urts/linux/sig_handler.h",
+    "psw/urts/linux/urts_emodpr.h",
+    "psw/urts/linux/urts_trim.h",
+    "psw/urts/loader.h",
+    "psw/urts/node.h",
+    "psw/urts/parser/binparser.h",
+    "psw/urts/parser/elf32parser.h",
+    "psw/urts/parser/elf64parser.h",
+    "psw/urts/parser/parserfactory.h",
+    "psw/urts/parser/section.h",
+    "psw/urts/prd_css_util.h",
+    "psw/urts/se_detect.h",
+    "psw/urts/section_info.h",
+    "psw/urts/tcs.h",
+]
+
+URTS_COMMON_TEXTUAL_HDRS = RTS_COMMON_TEXTUAL_HDRS + [
+    "psw/urts/parser/clearvars.h",
+    "psw/urts/linux/enter_enclave.h",
+    "psw/urts/parser/elfparser.h",
+    "psw/urts/parser/elfparser.cpp",
+    "psw/urts/parser/update_global_data.hxx",
+    "psw/urts/urts_com.h",
+]
+
+PSW_COMMON_SRCS = glob(["psw/ae/common/src/*.cpp"]) + [
+    "psw/uae_service/uae_wrapper/src/AEServicesImpl.cpp",
+    "psw/uae_service/uae_wrapper/src/AEServicesProvider.cpp",
+    "psw/uae_service/uae_wrapper/src/tae_ocall_api.cpp",
+    "psw/uae_service/uae_wrapper/src/uae_api.cpp",
+    "psw/uae_service/uae_service_assert.cpp",
+    "psw/uae_service/uae_service_version.cpp",
+]
+
+PSW_COMMON_HDRS = glob(["psw/ae/common/inc/*.h"]) + [
+    "common/inc/sgx_uae_service.h",
+    "psw/uae_service/uae_wrapper/inc/AEServices.h",
+    "psw/uae_service/config.h",
+    "psw/uae_service/uae_wrapper/inc/AEServicesImpl.h",
+    "psw/uae_service/uae_wrapper/inc/AEServicesProvider.h",
+    "psw/ae/aesm_service/source/upse/platform_info_blob.h",
+    "psw/ae/inc/aeerror.h",
+    "psw/ae/inc/byte_order.h",
+    "psw/ae/inc/se_sig_rl.h",
+    "psw/urts/linux/isgx_user.h",
+]
+
+PSW_COMMON_INCLUDES = [
+    "-Iexternal/linux_sgx/psw/ae/common/inc",
+    "-Iexternal/linux_sgx/psw/ae/common/proto",
+    "-Iexternal/linux_sgx/psw/uae_service/uae_wrapper/inc",
+    "-Iexternal/linux_sgx/psw/ae/inc",
+    "-Iexternal/linux_sgx/psw/ae/inc/internal",
+    "-Iexternal/linux_sgx/psw/ae/aesm_service/source",
+]
+
+filegroup(
+    name = "build_tools",
+    srcs = glob(["tools/**"]),
+)
+
+cc_library(
+    name = "se_wrapper",
+    srcs = [
+        "common/src/se_event.c",
+        "common/src/se_map.c",
+        "common/src/se_memory.c",
+        "common/src/se_rwlock.c",
+        "common/src/se_thread.c",
+        "common/src/se_time.c",
+        "common/src/se_trace.c",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    visibility = ["//visibility:private"],
+    deps = [
+        ":common_inc_internal",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "urts_hw",
+    srcs = URTS_COMMON_SRCS + PSW_COMMON_SRCS + [
+        "psw/uae_service/sgx_uae_service.cpp",
+        "psw/urts/enclave_creator_hw_com.cpp",
+        "psw/urts/linux/enclave_creator_hw.cpp",
+    ],
+    hdrs = URTS_COMMON_HDRS + PSW_COMMON_HDRS,
+    copts = PSW_COMMON_INCLUDES + [
+        "-DElfParser=Elf64Parser",
+        "-isystemcommon/inc/stdc++",
+        "-isystemcommon/inc/stdc++/linux",
+        "-Iexternal/linux_sgx/external/vtune/linux/include",
+        "-Iexternal/linux_sgx/external/vtune/linux/sdk/src/ittnotify",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/boringssl",
+    ],
+    linkopts = [
+        "-Wl,--no-as-needed -ldl",
+    ],
+    textual_hdrs = URTS_COMMON_TEXTUAL_HDRS + [
+        "common/inc/internal/se_lock.hpp",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":epid_inc",
+        ":ipc_common_proto_cc",
+        ":ittnotify_lib",
+        ":psw_switchless",
+        ":rts_common",
+        ":se_wrapper",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "ittnotify_lib",
+    srcs = [
+        "external/vtune/linux/include/legacy/ittnotify.h",
+        "external/vtune/linux/sdk/src/ittnotify/disable_warnings.h",
+        "external/vtune/linux/sdk/src/ittnotify/ittnotify_static.c",
+    ],
+    hdrs = [
+        "external/vtune/linux/include/ittnotify.h",
+        "external/vtune/linux/sdk/src/ittnotify/ittnotify_config.h",
+        "external/vtune/linux/sdk/src/ittnotify/ittnotify_types.h",
+    ],
+    copts = [
+        "-DITT_ARCH_IA64",
+        "-Iexternal/linux_sgx/external/vtune/linux/include",
+        "-Iexternal/linux_sgx/external/vtune/linux/sdk/src/ittnotify",
+    ],
+    textual_hdrs = [
+        "external/vtune/linux/sdk/src/ittnotify/ittnotify_static.h",
+    ],
+    visibility = ["//visibility:private"],
+)
+
+cc_binary(
+    name = "sgx_sign_tool",
+    srcs = [
+        "external/tinyxml2/tinyxml2.cpp",
+        "external/tinyxml2/tinyxml2.h",
+        "sdk/sign_tool/SignTool/elf_helper.h",
+        "sdk/sign_tool/SignTool/enclave_creator_sign.cpp",
+        "sdk/sign_tool/SignTool/enclave_creator_sign.h",
+        "sdk/sign_tool/SignTool/manage_metadata.cpp",
+        "sdk/sign_tool/SignTool/manage_metadata.h",
+        "sdk/sign_tool/SignTool/parse_key_file.cpp",
+        "sdk/sign_tool/SignTool/parse_key_file.h",
+        "sdk/sign_tool/SignTool/sign_tool.cpp",
+        "sdk/sign_tool/SignTool/util_st.cpp",
+        "sdk/sign_tool/SignTool/util_st.h",
+    ],
+    copts = [
+        "-Wno-sign-compare",
+        "-fpie",
+        "-Iexternal/linux_sgx/external/tinyxml2",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/linux_sgx/sdk/sign_tool/SignTool",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/boringssl",
+        "-DSE_DEBUG_LEVEL=SE_TRACE_DEBUG",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":untrusted_inc_internal",
+        ":urts",
+        "@boringssl//:crypto",
+    ],
+)
+
+TRTS_COMMON_SRCS = RTS_COMMON_SRCS + [
+    "sdk/trts/init_enclave.cpp",
+    "sdk/trts/init_optimized_lib.cpp",
+    "sdk/trts/linux/elf_parser.c",
+    "sdk/trts/linux/global_init.c",
+    "sdk/trts/linux/metadata_sec.S",
+    "sdk/trts/linux/tls_support.c",
+    "sdk/trts/linux/trts_pic.S",
+    "sdk/trts/linux/x86_64/setcontext.S",
+    "sdk/trts/trts.cpp",
+    "sdk/trts/trts_add_trim.cpp",
+    "sdk/trts/trts_ecall.cpp",
+    "sdk/trts/trts_emodpr.cpp",
+    "sdk/trts/trts_nsp.cpp",
+    "sdk/trts/trts_ocall.cpp",
+    "sdk/trts/trts_switchless.cpp",
+    "sdk/trts/trts_trim.cpp",
+    "sdk/trts/trts_util.cpp",
+    "sdk/trts/trts_veh.cpp",
+    "sdk/trts/trts_version.cpp",
+    "sdk/trts/trts_xsave.cpp",
+]
+
+TRTS_COMMON_HDRS = [
+    "sdk/cpprt/linux/libunwind/src/x86_64/ucontext_i.h",
+    "sdk/trts/init_optimized_lib.h",
+    "sdk/trts/linux/elf_parser.h",
+    "sdk/trts/trts_emodpr.h",
+    "sdk/trts/trts_trim.h",
+    "sdk/trts/trts_util.h",
+]
+
+TRTS_COMMON_TEXTUAL_HDRS = RTS_COMMON_TEXTUAL_HDRS + ["sdk/trts/linux/trts_pic.h"]
+
+cc_library(
+    name = "trts_common",
+    hdrs = [
+        "sdk/trts/trts_internal.h",
+        "sdk/trts/trts_shared_constants.h",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/trts",
+    ],
+    features = ["pic"],
+    deps = [
+        ":common_inc_internal",
+        ":trts_switchless",
+    ],
+)
+
+cc_library(
+    name = "trts_hw",
+    srcs = TRTS_COMMON_SRCS + TRTS_COMMON_HDRS,
+    copts = [
+        "-DISE=1",
+        "-DSL_INSIDE_ENCLAVE",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/trts",
+        "-Iexternal/linux_sgx/sdk/cpprt/linux/libunwind/src/x86_64",
+    ],
+    features = ["pic"],
+    linkopts = [
+        "-Wl,--no-as-needed",
+    ],
+    linkstatic = 1,
+    textual_hdrs = TRTS_COMMON_TEXTUAL_HDRS,
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":rts_common",
+        ":trts_common",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "trts_switchless",
+    srcs = SL_COMMON_SRCS + SL_COMMON_HDRS + [
+        "sdk/switchless/src/sgx_ocall_switchless.c",
+        "sdk/switchless/src/sl_fcall_mngr.c",
+        "sdk/switchless/src/sl_init.c",
+        "sdk/switchless/src/sl_memlog.c",
+        "sdk/switchless/src/sl_once.c",
+        "sdk/switchless/src/sl_printk.c",
+        "sdk/switchless/src/sl_siglines.c",
+        "sdk/switchless/src/sl_workers.c",
+    ],
+    copts = [
+        "-std=c11",
+        "-DSL_INSIDE_ENCLAVE",
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    features = ["pic"],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":sgx_runtime_support",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "trts_sim",
+    srcs = TRTS_COMMON_SRCS + TRTS_COMMON_HDRS + [
+        "sdk/selib/sgx_create_report.cpp",
+        "sdk/selib/sgx_get_key.cpp",
+        "sdk/selib/sgx_verify_report.cpp",
+        "sdk/selib/tservice_version.cpp",
+    ],
+    copts = [
+        "-DSE_SIM=1",
+        "-DISE=1",
+        "-DSL_INSIDE_ENCLAVE",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/trts",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/cpprt/linux/libunwind/src/x86_64",
+    ],
+    features = ["pic"],
+    linkopts = [
+        "-Wl,--defsym,__ImageBase=0",
+    ],
+    linkstatic = 1,
+    textual_hdrs = TRTS_COMMON_TEXTUAL_HDRS,
+    deps = [
+        ":common_inc_internal",
+        ":tinst_sim",
+        ":trts_common",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+    ],
+    alwayslink = 1,
+)
+
+cc_library(
+    name = "rts_common",
+    srcs = [
+        "common/src/crypto_cmac_128.cpp",
+        "common/src/crypto_evp_digest.cpp",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/boringssl",
+    ],
+    features = ["pic"],
+    visibility = ["//visibility:private"],
+    deps = [
+        ":common_inc_internal",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "sim_common",
+    srcs = [
+        "sdk/simulation/assembly/linux/lowlib.S",
+        "sdk/simulation/uinst/linux/restore_tls.c",
+    ],
+    hdrs = [
+        "sdk/simulation/assembly/linux/gnu_tls.h",
+        "sdk/simulation/assembly/lowlib.h",
+        "sdk/simulation/tinst/deriv.h",
+        "sdk/simulation/tinst/rts_sim.h",
+        "sdk/simulation/uinst/td_mngr.h",
+    ],
+    copts = [
+        "-DSE_SIM=1",
+        "-Wa,--noexecstack",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly/linux",
+    ],
+    linkopts = [
+        "-Wl,--no-as-needed",
+    ],
+    linkstatic = 1,
+    textual_hdrs = RTS_COMMON_TEXTUAL_HDRS,
+    visibility = ["//visibility:private"],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":rts_common",
+    ],
+)
+
+cc_library(
+    name = "tinst_sim",
+    srcs = [
+        "sdk/simulation/tinst/deriv.cpp",
+        "sdk/simulation/tinst/t_instructions.cpp",
+    ],
+    hdrs = [
+        "sdk/simulation/tinst/t_instructions.h",
+    ],
+    copts = [
+        "-DSE_SIM=1",
+        "-fno-rtti",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly",
+    ],
+    deps = [
+        ":sim_common",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "uae_service_sim",
+    srcs = PSW_COMMON_SRCS + [
+        "common/src/sgx_read_rand.cpp",
+        "external/rdrand/rdrand.h",
+        "external/rdrand/src/config.h",
+        "external/rdrand/src/rdrand.c",
+        "external/rdrand/src/rdrand.h",
+        "psw/ae/common/se_sig_rl.cpp",
+        "sdk/simulation/uae_service_sim/licensing_sim.cpp",
+        "sdk/simulation/uae_service_sim/linux/platform_service_sim.cpp",
+        "sdk/simulation/uae_service_sim/platform_service_sim_com.cpp",
+        "sdk/simulation/uae_service_sim/quoting_sim.cpp",
+        "sdk/simulation/uae_service_sim/uae_service_sim.h",
+        "sdk/simulation/urtssim/cpusvn_util.h",
+    ],
+    hdrs = PSW_COMMON_HDRS,
+    copts = PSW_COMMON_INCLUDES + [
+        "-DSE_SIM=1",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/linux_sgx/external/epid-sdk/ext/ipp/include",
+        "-Iexternal/linux_sgx/external/rdrand",
+        "-Iexternal/linux_sgx/psw/ae/common",
+        "-Iexternal/linux_sgx/sdk/simulation/uae_service_sim",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/urtssim",
+        "-Iexternal/linux_sgx/sdk/tseal",
+    ],
+    linkopts = [
+        "-Wl,--no-as-needed -ldl",
+        "-Wl,--export-dynamic",
+        "-lrt",
+    ],
+    visibility = ["//visibility:private"],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":epid_inc",
+        ":ipc_common_proto_cc",
+        ":sim_common",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+        ":untrusted_sim_inc",
+    ],
+)
+
+cc_library(
+    name = "untrusted_sim_inc",
+    hdrs = [
+        "psw/ae/inc/internal/pse_types.h",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "psw_switchless",
+    srcs = SL_COMMON_SRCS + SL_COMMON_HDRS + [
+        "psw/uswitchless/sgx_ecall_switchless_untrusted.c",
+        "psw/uswitchless/sl_fcall_mngr_untrusted.c",
+        "psw/uswitchless/sl_siglines_untrusted.c",
+        "psw/uswitchless/sl_uswitchless_untrusted.c",
+        "psw/uswitchless/sl_workers_untrusted.c",
+    ],
+    copts = ["-Iexternal/linux_sgx/common/inc/internal"],
+    features = ["pic"],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "urts_sim",
+    srcs = URTS_COMMON_SRCS + [
+        "sdk/simulation/assembly/linux/sgxsim.S",
+        "sdk/simulation/assembly/sgxsim.h",
+        "sdk/simulation/driver_api/driver_api.cpp",
+        "sdk/simulation/uinst/enclave_mngr.cpp",
+        "sdk/simulation/uinst/enclave_mngr.h",
+        "sdk/simulation/uinst/linux/get_tcs.c",
+        "sdk/simulation/uinst/linux/set_tls.c",
+        "sdk/simulation/uinst/u_instructions.cpp",
+        "sdk/simulation/uinst/u_instructions.h",
+        "sdk/simulation/urtssim/cpusvn_util.cpp",
+        "sdk/simulation/urtssim/cpusvn_util.h",
+        "sdk/simulation/urtssim/enclave_creator_sim.cpp",
+        "sdk/simulation/urtssim/enclave_creator_sim.h",
+        "sdk/simulation/urtssim/get_state.cpp",
+        "sdk/simulation/urtssim/urts_sim.h",
+    ],
+    hdrs = URTS_COMMON_HDRS + PSW_COMMON_HDRS,
+    copts = PSW_COMMON_INCLUDES + [
+        "-DSE_SIM=1",
+        "-DElfParser=Elf64Parser",
+        "-Wa,--noexecstack",
+        "-Iexternal/linux_sgx/external/vtune/linux/include",
+        "-Iexternal/linux_sgx/external/vtune/linux/sdk/src/ittnotify",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/sdk/simulation/urtssim",
+        "-Iexternal/boringssl",
+    ],
+    features = ["pic"],  # Not trusted, but Intel's Makefile has -fPIC
+    linkopts = [
+        "-Wl,--no-as-needed -ldl",
+    ],
+    linkstatic = 1,
+    textual_hdrs = URTS_COMMON_TEXTUAL_HDRS + [
+        "sdk/simulation/assembly/linux/sw_emu.h",  # included as ASM
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":epid_inc",
+        ":ipc_common_proto_cc",
+        ":ittnotify_lib",
+        ":psw_switchless",
+        ":se_wrapper",
+        ":sim_common",
+        ":uae_service_sim",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+        ":untrusted_sim_inc",
+        "@boringssl//:crypto",
+    ],
+)
+
+# The headers that are common across trusted and untrusted targets.
+cc_library(
+    name = "common_inc",
+    hdrs = [
+        "common/inc/sgx.h",
+        "common/inc/sgx_attributes.h",
+        "common/inc/sgx_cpuid.h",
+        "common/inc/sgx_defs.h",
+        "common/inc/sgx_dh.h",
+        "common/inc/sgx_ecp_types.h",
+        "common/inc/sgx_edger8r.h",
+        "common/inc/sgx_eid.h",
+        "common/inc/sgx_error.h",
+        "common/inc/sgx_key.h",
+        "common/inc/sgx_key_exchange.h",
+        "common/inc/sgx_lfence.h",
+        "common/inc/sgx_quote.h",
+        "common/inc/sgx_report.h",
+        "common/inc/sgx_tae_service.h",
+        "common/inc/sgx_tcrypto.h",
+        "common/inc/sgx_thread.h",
+        "common/inc/sgx_tseal.h",
+        "common/inc/sgx_uswitchless.h",
+    ],
+    includes = [
+        "common/inc",
+    ],
+    visibility = ["//visibility:private"],
+)
+
+cc_library(
+    name = "untrusted_inc",
+    hdrs = [
+        "common/inc/sgx_urts.h",
+    ],
+    visibility = ["//visibility:private"],
+    deps = [":common_inc"],
+)
+
+cc_library(
+    name = "common_inc_internal",
+    srcs = [
+        "common/src/sl_memlog_common.c",
+        "common/src/sl_once_common.c",
+    ],
+    hdrs = [
+        "common/inc/internal/arch.h",
+        "common/inc/internal/cpputil.h",
+        "common/inc/internal/cpuid.h",
+        "common/inc/internal/crypto_wrapper.h",
+        "common/inc/internal/elf_util.h",
+        "common/inc/internal/elfheader/elf_common.h",
+        "common/inc/internal/elfheader/elfstructs.h",
+        "common/inc/internal/global_data.h",
+        "common/inc/internal/linux/cpuid_gnu.h",
+        "common/inc/internal/metadata.h",
+        "common/inc/internal/mini_snprintf.h",
+        "common/inc/internal/routine.h",
+        "common/inc/internal/rts.h",
+        "common/inc/internal/rts_cmd.h",
+        "common/inc/internal/se_cdefs.h",
+        "common/inc/internal/se_cpu_feature_defs.h",
+        "common/inc/internal/se_error_internal.h",
+        "common/inc/internal/se_macro.h",
+        "common/inc/internal/se_memcpy.h",
+        "common/inc/internal/se_page_attr.h",
+        "common/inc/internal/se_quote_internal.h",
+        "common/inc/internal/se_stdio.h",
+        "common/inc/internal/se_string.h",
+        "common/inc/internal/se_types.h",
+        "common/inc/internal/se_version.h",
+        "common/inc/internal/sgx_memset_s.h",
+        "common/inc/internal/sl_atomic.h",
+        "common/inc/internal/sl_bitops.h",
+        "common/inc/internal/sl_compiler.h",
+        "common/inc/internal/sl_init.h",
+        "common/inc/internal/sl_memlog.h",
+        "common/inc/internal/sl_once.h",
+        "common/inc/internal/sl_printk.h",
+        "common/inc/internal/sl_spinlock.h",
+        "common/inc/internal/sl_types.h",
+        "common/inc/internal/sl_util.h",
+        "common/inc/internal/thread_data.h",
+        "common/inc/internal/uncopyable.h",
+        "common/inc/internal/uswitchless.h",
+        "common/inc/internal/util.h",
+        "common/inc/internal/xsave.h",
+    ],
+    copts = [
+        # common/inc/internal cannot be included via "includes" since
+        # __cpuid gets overwritten with an incompatible definition from
+        # the usual cpuid.h header file.
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/boringssl",
+    ],
+    textual_hdrs = [
+        "common/inc/internal/inst.h",
+    ],
+    visibility = ["//visibility:private"],
+    deps = [
+        ":common_inc",
+        ":epid_inc",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "untrusted_inc_internal",
+    hdrs = [
+        "common/inc/internal/driver_api.h",
+        "common/inc/internal/oal/uae_oal_api.h",
+        "common/inc/internal/se_atomic.h",
+        "common/inc/internal/se_debugger_lib.h",
+        "common/inc/internal/se_event.h",
+        "common/inc/internal/se_lock.hpp",
+        "common/inc/internal/se_map.h",
+        "common/inc/internal/se_memory.h",
+        "common/inc/internal/se_rwlock.h",
+        "common/inc/internal/se_string.h",
+        "common/inc/internal/se_thread.h",
+        "common/inc/internal/se_time.h",
+        "common/inc/internal/se_trace.h",
+        "common/inc/internal/se_vendor.h",
+        "common/inc/internal/se_wrapper.h",
+        "common/inc/internal/sgx_read_rand.h",
+        "common/inc/internal/uae_service_internal.h",
+        "psw/ae/inc/internal/aesm_error.h",
+        "psw/ae/inc/internal/epid_pve_type.h",
+    ],
+    copts = [
+        "-DSL_INSIDE_ENCLAVE",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/psw/ae/inc/internal",
+        "-Iexternal/boringssl",
+    ],
+    visibility = ["//visibility:private"],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":epid_inc",
+        ":untrusted_inc",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "public",
+    hdrs = [
+        "include/global_data.h",
+        "include/sgx_cpuid.h",
+        "include/sgx_edger8r.h",
+        "include/sgx_eid.h",
+        "include/sgx_error.h",
+        "include/sgx_lfence.h",
+        "include/sgx_thread.h",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "epid_inc",
+    hdrs = [
+        "external/epid-sdk/epid/common/bitsupplier.h",
+        "external/epid-sdk/epid/common/epiddefs.h",
+        "external/epid-sdk/epid/common/errors.h",
+        "external/epid-sdk/epid/common/types.h",
+        "external/epid-sdk/epid/member/api.h",
+    ],
+    includes = [
+        "external/epid-sdk",
+    ],
+)
+
+# Target selecting either simulation or hardware mode untrusted include files
+# based on the value of SGX_SIM.
+cc_library(
+    name = "urts",
+    # Reprovide untrusted_inc's header to avoid layering violation.
+    hdrs = URTS_COMMON_HDRS + ["include/sgx_urts.h"],
+    copts = [
+        "-Wa,--noexecstack",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/linux_sgx/external/epid-sdk/ext/ipp/include",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/sdk/simulation/urtssim",
+        "-Iexternal/linux_sgx/psw/ae/inc/internal",
+        "-Iexternal/linux_sgx/psw/ae/inc",
+        "-Iexternal/boringssl",
+    ],
+    deps = [
+        ":common_inc",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+        ":common_inc_internal",
+    ] + select({
+        ":sgx_hw": [
+            ":urts_hw",
+        ],
+        "//conditions:default": [
+            ":urts_sim",
+        ],
+    }),
+)
+
+# The following targets are designed with to be build with the Asylo toolchain.
+cc_library(
+    name = "trusted_inc",
+    srcs = [
+        "sdk/tlibc/gen/se_cpuid.c",
+    ],
+    hdrs = [
+        "common/inc/sgx_trts.h",
+        "common/inc/sgx_trts_exception.h",
+        "common/inc/sgx_utils.h",
+    ],
+    copts = [
+        "-ffreestanding",
+    ],
+    visibility = ["//visibility:private"],
+    deps = [
+        ":common_inc",
+        ":sgx_runtime_support",
+        ":sgx_spin_lock",
+    ],
+)
+
+cc_library(
+    name = "sgx_runtime_support",
+    srcs = [
+        "runtime_support/sgx_init_crypto_lib.c",
+        "runtime_support/sgx_init_string_lib.c",
+        "sdk/compiler-rt/stack_chk.c",
+        "sdk/tlibc/string/consttime_memequal.c",
+        "sdk/tlibc/string/memset_s.c",
+    ],
+    hdrs = [
+        "runtime_support/rts_config.h",
+    ],
+    includes = ["runtime_support"],
+    deps = [":common_inc"],
+)
+
+cc_library(
+    name = "trusted_inc_internal",
+    hdrs = [
+        "common/inc/internal/cpprt_internal.h",
+        "common/inc/internal/dh.h",
+        "common/inc/internal/ecp_interface.h",
+        "common/inc/internal/global_init.h",
+        "common/inc/internal/pcl_common.h",
+        "common/inc/internal/se_cpu_feature.h",
+        "common/inc/internal/se_enclave_type.h",
+        "common/inc/internal/se_tcrypto_common.h",
+        "common/inc/internal/sgx_ecc256_internal.h",
+        "common/inc/internal/sgx_profile.h",
+        "common/inc/internal/sgx_sha256_128.h",
+        "common/inc/internal/ssl_wrapper.h",
+        "common/inc/internal/tae_service_internal.h",
+        "common/inc/internal/trts_inst.h",
+        "common/inc/internal/tseal_migration_attr.h",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/trts/",
+        "-Iexternal/boringssl",
+    ],
+    linkopts = ["-Wl,--export-dynamic"],
+    visibility = ["//visibility:private"],
+    deps = [
+        ":common_inc",
+        ":epid_inc",
+        ":sgx_spin_lock",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "sgx_tthread",
+    srcs = [
+        "sdk/tlibthread/sethread_cond.cpp",
+        "sdk/tlibthread/sethread_internal.h",
+        "sdk/tlibthread/sethread_mutex.cpp",
+        "sdk/tlibthread/sethread_utils.cpp",
+    ],
+    copts = [
+        "-g -O0",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/tlibcrypto",
+        "-Iexternal/linux_sgx/sdk/trts",
+    ],
+    linkstatic = 1,
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":trts_common",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "sgx_tcrypto",
+    srcs = [
+        "sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp",
+        "sdk/tlibcrypto/tcrypto_version.cpp",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/tlibcrypto",
+        "-DUSE_SGXSSL",
+        "-Iexternal/boringssl",
+    ],
+    linkopts = [
+        "-Wl,--export-dynamic",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+        "@boringssl//:crypto",
+    ],
+)
+
+# A wrapping library that wraps linux_sgx targets used by enclave.
+cc_library(
+    name = "intel_runtime",
+    deps = [
+        ":common_inc",
+        ":sgx_spin_lock",
+        ":sgx_tcrypto",
+        ":sgx_tthread",
+        ":trts",
+        ":trusted_inc",
+    ],
+)
+
+
+cc_library(
+    name = "sgx_spin_lock",
+    srcs = ["sdk/tlibc/gen/spinlock.c"],
+    hdrs = ["common/inc/sgx_spinlock.h"],
+    copts = [
+        "-ffreestanding",
+    ],
+    deps = [":common_inc"],
+)
+
+
+# Target selecting either simulation or hardware mode trusted include files
+# based on the value of SGX_SIM.
+cc_library(
+    name = "trts",
+    hdrs = [
+        "include/sgx.h",
+        "include/sgx_trts.h",
+        "include/sgx_trts_exception.h",
+    ],
+    deps = [
+        ":common_inc",
+        ":trusted_inc",
+    ] + select({
+        ":sgx_hw": [
+            ":trts_hw",
+        ],
+        ":sgx_sim": [
+            ":trts_sim",
+        ],
+        "//conditions:default": [],
+    }),
+)
+
+# The edger8r tool uses an language unsupported by Bazel, so call ocamlbuild
+# in a genrule. (sudo apt-get install ocaml)
+filegroup(
+    name = "edger8r_srcs",
+    srcs = [
+        "sdk/edger8r/linux/Ast.ml",
+        "sdk/edger8r/linux/CodeGen.ml",
+        "sdk/edger8r/linux/Edger8r.ml",
+        "sdk/edger8r/linux/Lexer.mll",
+        "sdk/edger8r/linux/Parser.mly",
+        "sdk/edger8r/linux/Preprocessor.ml",
+        "sdk/edger8r/linux/SimpleStack.ml",
+        "sdk/edger8r/linux/Util.ml",
+    ],
+)
+
+genrule(
+    name = "sgx_edger8r",
+    srcs = [":edger8r_srcs"],
+    outs = ["sgx_edger8r_binary"],
+    cmd = "OUT=`pwd`/$(@); " +
+          "BUILD=`mktemp -d`; " +
+          "LOCS=($(locations :edger8r_srcs)); " +
+          "cd $$(dirname \"$${LOCS[0]}\"); " +
+          # Call ocamlbuild directly instead of make since the default
+          # build directory can get permission denied on mkdir.
+          "ocamlbuild -libs str,unix -build-dir $$BUILD Edger8r.native > /dev/null; " +
+          "cp $$BUILD/Edger8r.native $$OUT",
+    executable = True,
+    output_to_bindir = True,
+)
+
+# These configuration settings are used to select build configurations based
+# on if building for hardware or simulation sgx enclaves.
+#   --config=sgx adds --define="SGX_SIM=0"
+#   --config=sgx-sim adds --define="SGX_SIM=1"
+# By default enclave launching applications will support simulation enclaves.
+# You can manually specify "bazel build --define="SGX_SIM=1" :mytarget" to
+# support hardware enclaves.
+config_setting(
+    name = "sgx_hw",
+    values = {
+        "define": "SGX_SIM=0",
+    },
+)
+
+config_setting(
+    name = "sgx_sim",
+    values = {
+        "define": "SGX_SIM=1",
+    },
+)
--- /dev/null
+++ sgx_sdk.bzl
@@ -0,0 +1,209 @@
+"""Build tools for supporting Intel's SDK."""
+
+load("@com_google_asylo_backend_provider//:enclave_info.bzl", "enclave_info")
+
+sgx_enclave_info = provider()
+sgx_enclave_config = provider()
+
+
+def _sgx_unsigned_enclave(
+        name,
+        **kwargs):
+    """Build rule for creating an unsigned SGX enclave shared object file.
+
+    Args:
+      name: The enclave target name.
+      **kwargs: cc_binary arguments.
+    """
+
+    # Append enclave specific arguments.
+    kwargs["copts"] = kwargs.get("copts", []) + [
+        "-Iexternal/linux_sgx/v_2_1_3/common/inc/",
+        "-fstack-protector",
+    ]
+
+    lds_label = "@linux_sgx//:enclave_sim.lds"
+    kwargs["features"] = kwargs.get("features", []) + [
+        "fully_static_link",
+    ]
+    kwargs["linkopts"] = kwargs.get("linkopts", []) + [
+        "-Wl,-Bstatic",
+        "-Wl,-Bsymbolic",
+        "-Wl,-pie,-eenclave_entry",
+        "-Wl,--defsym,__ImageBase=0",
+        "-Wl,--export-dynamic",
+        "-Wl,--version-script",
+        "$(location %s)" % lds_label,
+    ]
+    kwargs["linkshared"] = 1
+    kwargs["linkstatic"] = 1
+    kwargs["deps"] = kwargs.get("deps", []) + [
+        lds_label,
+        "@linux_sgx//:intel_runtime",
+    ]
+
+    # Create rule to build unsigned enclave.
+    native.cc_binary(
+        name = name,
+        visibility = None,
+        **kwargs
+    )
+
+def _sgx_enclave_configuration(ctx):
+    """Implementation of enclave signing configuration file formatting."""
+    xml_file = ctx.actions.declare_file(ctx.label.name + ".xml")
+    ctx.file_action(
+        output = xml_file,
+        content = "\n".join([
+            "<EnclaveConfiguration>",
+            "  <ProdID>%s</ProdID>" % ctx.attr.prodid,
+            "  <ISVSVN>%s</ISVSVN>" % ctx.attr.isvsvn,
+            "  <StackMaxSize>%s</StackMaxSize>" % ctx.attr.stack_max_size,
+            "  <HeapMaxSize>%s</HeapMaxSize>" % ctx.attr.heap_max_size,
+            "  <TCSNum>%s</TCSNum>" % ctx.attr.tcs_num,
+            "  <TCSPolicy>%s</TCSPolicy>" % ctx.attr.tcs_policy,
+            "  <DisableDebug>%s</DisableDebug>" % ctx.attr.disable_debug,
+            "  <MiscSelect>%s</MiscSelect>" % ctx.attr.misc_select,
+            "  <MiscMask>%s</MiscMask>" % ctx.attr.misc_mask,
+            "</EnclaveConfiguration>\n\n",
+        ]),
+    )
+    return [DefaultInfo(files = depset([xml_file])), sgx_enclave_config()]
+
+sgx_enclave_configuration = rule(
+    implementation = _sgx_enclave_configuration,
+    output_to_genfiles = True,
+    attrs = {
+        "prodid": attr.string(default = "0"),
+        "isvsvn": attr.string(default = "0"),
+        "stack_max_size": attr.string(default = "0x40000"),
+        "heap_max_size": attr.string(default = "0x100000"),
+        "tcs_num": attr.string(default = "10"),
+        "tcs_policy": attr.string(default = "1"),
+        # "1" for release enclaves.
+        "disable_debug": attr.string(default = "0"),
+        "misc_select": attr.string(default = "0"),
+        "misc_mask": attr.string(default = "0xffffffff"),
+    },
+)
+
+def _sgx_debug_sign_enclave_impl(ctx):
+    """Implementation of an automated signing process of an unsigned enclave."""
+    ctx.actions.run_shell(
+        inputs = [
+            ctx.executable._sign_tool,
+            ctx.file.unsigned,
+            ctx.file._key,
+            ctx.file.config,
+        ],
+        outputs = [ctx.outputs.executable],
+        progress_message = "Signing for debug: //{pkg}:{name}".format(
+            pkg = ctx.attr.unsigned.label.package,
+            name = ctx.attr.unsigned.label.name,
+        ),
+        # Suppresses tool output on success.
+        command = "output=`%s $@ 2>&1` || echo $output" %
+                  ctx.executable._sign_tool.path,
+        arguments = [
+            "sign",
+            "-enclave",
+            ctx.file.unsigned.path,
+            "-key",
+            ctx.file._key.path,
+            "-config",
+            ctx.file.config.path,
+            "-out",
+            ctx.outputs.executable.path,
+        ],
+    )
+    return [
+        DefaultInfo(files = depset([ctx.outputs.executable])),
+        enclave_info(),
+        sgx_enclave_info(),
+    ]
+
+# Skylark rule for the above implementation. Gives default debug arguments for
+# private attributes for signing tool, signing key, and signing configuration.
+_sgx_debug_sign_enclave = rule(
+    implementation = _sgx_debug_sign_enclave_impl,
+    executable = True,
+    attrs = {
+        "unsigned": attr.label(allow_single_file = True),
+        "config": attr.label(
+            mandatory = True,
+            allow_single_file = True,
+            providers = [sgx_enclave_config],
+        ),
+        "_sign_tool": attr.label(
+            default = Label("@linux_sgx//:sgx_sign_tool"),
+            allow_single_file = True,
+            executable = True,
+            cfg = "host",
+        ),
+        "_key": attr.label(
+            default = Label(
+                "@linux_sgx//:enclave_test_private.pem",
+            ),
+            allow_single_file = True,
+        ),
+    },
+)
+
+def sgx_enclave(
+        name,
+        config = "@linux_sgx//:enclave_debug_config",
+        testonly = 0,
+        **kwargs):
+    """Build rule for creating SGX enclave shared object files signed for testing.
+
+    The enclave is signed with test key stored in
+    @linux_sgx//:enclave_test_private.pem.
+
+    This macro creates two build targets:
+      1) name_unsigned.so: cc_binary that builds the unsigned enclave.
+      2) name: internal signing rule that (debug) signs name_unsigned.so.
+
+    Args:
+      name: The debug-signed enclave target name.
+      config: An sgx_enclave_configuration rule.
+      testonly: 0 or 1, set to 1 if the target is only used in tests.
+      **kwargs: cc_binary arguments.
+    Returns:
+      string: The name of the signed enclave.
+    """
+    unsigned_name = _unsigned_enclave_name(name)
+
+    _sgx_unsigned_enclave(
+        name = unsigned_name,
+        testonly = testonly,
+        **kwargs
+    )
+
+    _sgx_debug_sign_enclave(
+        name = name,
+        unsigned = unsigned_name,
+        config = config,
+        testonly = testonly,
+    )
+
+    return name
+
+
+
+def _extend_enclave_name(enclave, str):
+    """Injects 'str' before '.so' if '.so' in enclave, otherwise appends 'str.so'.
+
+    Args:
+      enclave: Input string
+      str: String to append.
+
+    Returns:
+      string: Name of enclave with str appended.
+    """
+    if ".so" not in enclave:
+        return enclave + str + ".so"
+    else:
+        return enclave.replace(".so", str + ".so", 1)
+
+def _unsigned_enclave_name(enclave):
+    return _extend_enclave_name(enclave, "_unsigned")
--- /dev/null
+++ enclave_test_private.pem
@@ -0,0 +1,39 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIG5AIBAAKCAYEA4USJ5KMsrAyhVMBo0omE3sQMRszt068hwmundFI+NWFOlB02
+kBlws+Zym8zwV07OyQVGX6BmbbbjE3csCbMA71rfJelIi+0JuHJcFeYYa7FwY07m
+aOfqzn9B0zTfbf4FPDAH7gYQtBbceHT7uuFHAk+EWrvckzDTl1huMOhv0s5+p0j/
+pwNslTZwrpFGlLcIeB6YQflxshWAQ8QbZEORajR2Y6HzfmK02vwqKQuEnCioMHdF
+16c7amdzMDU5QYdhUZvPLmzl0Wlmt/s5bfS39DWITtKs8FgqIagMjvUIeOFuEn4n
+3XnT8+FIYfCrn8/OgVbdm5v2s9Rs7EJENBuALPR210R9f+aqHBPuKQFmkSpyVR/Y
+W8uSuYCAX8jMVh9e3iI3AK9KIsDxZN26/+tQNF1UDEUJ9Et3q9ESsOCjU+rdnbnG
+waw6hIPsD+DqhksS8yqq1znfEK814jkwm82npqHZObkloRQOM8ZjiyiWHrn0M9K7
+LbJfWkMgGBkhWDo5AgEDAoIBgQCWLbFDF3MdXcDjKvCMW63p2AgvM0k3yhaBnRpN
+jCl464m4E3m1ZksimaG9M0rk3zSGA4Q/wERJJJdiT3KxIgCfkeoZRjBdSLEloZK5
+RBBHy6BCNJmbRUc0VNaMzepJVAN9dVqerrXNZJL6+KfR64SsNQLnJ+hiII0PkEl1
+8EqMianE21UaAkhjeaB0YNm4egWlabrWpkvMDlWCgrztgmDxeE7tFqJUQc3nUsbG
+B629cHAgT4PlGiecRPd1eNDWWj+gxMA5O0MInI06iSd6nVhvd4IF1IzDOtffbZI8
+j+MakfLTct8/VGdrlFo7LycJ8rbOXsXqwMI8c7QhOdax+AysvJfzp7A6m54vtHlu
++csQmAOriJlJH+zfe8m3m0mlLD9iipSXeB8GLGaES1h46Dh3XILMJQEBR1NPIHMN
+eIqp0wfy8RJj7Z9NwXp0Y11H33upsm3HQzmmXAMq2U6ZU7v5/JwjWWguTsvI0rhi
+b189KRaAkUFoCk+8xuWMglWw+sMCgcEA9p+c8Ld8GfK0IC/X8fT9HzI/Q7L1NWyD
+edKanoUuOpxjO2cPFHuV2LnXy42W9TYpFi+3AVLvODS+QusqYHM/FOi24gS8vp1O
+a4r7SxYR5ssdpHFFLrWRsV78FX1427zjr8nlW66R06ewLILbN2q4rd3ICXU6USUu
+lfPojXGu6h0E84icD0A65npUhdLgYbQGMENgvkI5Y/fqPCasbnCfUHaDWQ+J5UI1
+GO74PgRKXHj0j11VjlT/KIaoex0HbHhDAoHBAOnVEefchSqL3r/9pkQTti3QBgJg
+5JYTYtixFpWYBZZqHpnqyen/ovnI6T2cWhutkzWY/bon5CDyIHeAV8i0LhTw3AfE
+OGlf7mj6PLd0pBF7Ty9hrT9mHbjn1bbiZQKgHBqIcsHMicXWp3Hp2xMkQtN0x9CY
+TiE7TB8sfY86JGsRTL3HjxyHkKlnX9t4/jjH00RbpW4SzzMtRuXMjkdfbl8wa6uj
+f3Zbp22bVrl9POaDXeObg4NN6JaSH0o4mWJJ0wKBwQCkamigelK79yLAH+VL+Ki/
+dtTXzKN48wJRNxG/A3QnEuzSRLS4UmPl0TqHs7n4zsYOynoA4fTQIymB8hxATNS4
+mySWrdMpvjRHsfzcuWFEh2kYS4N0eQvLlKgOU6Xn00J1MUOSdGE3xSAdrJIk8dBz
+6TAGTibgw3Rj9/BeS8nxaK33sGgKKtHu/DhZN0BBIq7K15XULCZCpUbSxHL0SxTg
+TwI7X7FDgXi7SfrUAtw9pfhfk45e41TFrxr8vgTy+tcCgcEAm+NhRT2uHF0/KqkZ
+grfOyTVZVutDDreXOyC5uRADuZwUZpyGm//B+9tGKRLmvR5iI7tT0W/ta0wVpQA6
+hc10DfXoBS168Oqe8KbTJPhtYPzfdOvI1O6+e0U5JJbuAcASvFr3K92xLo8aS/E8
+t22B4k3aixA0FieIFMhTtNFtnLYzKS+0va+1xkTqklCpey/iLZJuSWHfd3OEmTMJ
+hOpJlMrycmz/pD0aSRI50P4omazpQmetAjPwZGFqMXsQ7DE3AoHBAOgLMALK+foN
+OW2hfzKPV2UMdlOCFqexftgyL/taWvPDti1S0WfbXITqG3hfy9SyLhjPmMxEkqNy
+oJMNil43sG9UoZf++wrEvYx5DZY/r106SaJaMIo6R3ovbpETLvk9TSUdFPpsx7Bo
+1qZ1G0iWFhpzgwunLTSkAnfUaDQF4frljR7iCLi1HrVz5BnQMCvpEKm8kvKNx1vD
+JSQsCoVS/0pKvNk4D9Lodq5q3anBI+R0JRlpzNTjefbQPdoWXALoMA==
+-----END RSA PRIVATE KEY-----
--- /dev/null
+++ enclave_sim.lds
@@ -0,0 +1,9 @@
+enclave.so
+{
+    global:
+        enclave_entry;
+        g_global_data;
+        g_global_data_sim;
+    local:
+        *;
+};
--- /dev/null
+++ runtime_support/rts_config.h
@@ -0,0 +1,30 @@
+#ifndef _RUNTIME_SUPPORT_RTS_CONFIG_H_
+#define _RUNTIME_SUPPORT_RTS_CONFIG_H_
+
+#include <string.h>
+
+#ifndef _ERNNO_T_DEFINED
+#define _ERRNO_T_DEFINED
+typedef int errno_t;
+#endif
+
+#ifndef HAVE_SET_UCONTEXT
+#define HAVE_SET_UCONTEXT
+ #ifndef __linux__
+ #define __linux__
+ #endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+errno_t memset_s(void *s, size_t smax, int c, size_t n);
+
+int consttime_memequal(const void *b1, const void *b2, size_t len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // _RUNTIME_SUPPORT_RTS_CONFIG_H_
--- /dev/null
+++ runtime_support/sgx_init_string_lib.c
@@ -0,0 +1,8 @@
+
+#include <stdint.h>
+
+int __NR_rt_sigprocmask;
+
+int sgx_init_string_lib(uint64_t cpu_feature_indicator) {
+  return 0;
+}
--- /dev/null
+++ runtime_support/sgx_init_crypto_lib.c
@@ -0,0 +1,10 @@
+
+#include <stdint.h>
+
+#include "sgx_error.h"
+
+sgx_status_t sgx_init_crypto_lib(uint64_t cpu_feature_indicator,
+                                 uint32_t *cpuid_table) {
+  return SGX_SUCCESS;
+}
+
--- /dev/null
+++ include/global_data.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_GLOBAL_DATA_H_
+#define _INCLUDE_GLOBAL_DATA_H_
+
+#include "common/inc/internal/global_data.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_GLOBAL_DATA_H_
--- /dev/null
+++ include/sgx.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_H_
+#define _INCLUDE_SGX_H_
+
+#include "common/inc/sgx.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_H_
--- /dev/null
+++ include/sgx_cpuid.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_INCLUDE_SGX_CPUID_H_
+#define _INCLUDE_INCLUDE_SGX_CPUID_H_
+
+#include "common/inc/sgx_cpuid.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_INCLUDE_SGX_CPUID_H_
--- /dev/null
+++ include/sgx_edger8r.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_EDGER8R_H_
+#define _INCLUDE_SGX_EDGER8R_H_
+
+#include "common/inc/sgx_edger8r.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_EDGER8R_H_
--- /dev/null
+++ include/sgx_eid.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_EID_H_
+#define _INCLUDE_SGX_EID_H_
+
+#include "common/inc/sgx_eid.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_EID_H_
--- /dev/null
+++ include/sgx_error.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_ERROR_H_
+#define _INCLUDE_SGX_ERROR_H_
+
+#include "common/inc/sgx_error.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_ERROR_H_
--- /dev/null
+++ include/sgx_lfence.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_LFENCE_H_
+#define _INCLUDE_SGX_LFENCE_H_
+
+#include "common/inc/sgx_lfence.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_LFENCE_H_
--- /dev/null
+++ include/sgx_thread.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_THREAD_H_
+#define _INCLUDE_SGX_THREAD_H_
+
+#include "common/inc/sgx_thread.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_THREAD_H_
--- /dev/null
+++ include/sgx_trts.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_TRTS_H_
+#define _INCLUDE_SGX_TRTS_H_
+
+#include "common/inc/sgx_trts.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_TRTS_H_
--- /dev/null
+++ include/sgx_trts_exception.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_TRTS_EXCEPTION_H_
+#define _INCLUDE_SGX_TRTS_EXCEPTION_H_
+
+#include "common/inc/sgx_trts_exception.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_TRTS_EXCEPTION_H_
--- /dev/null
+++ include/sgx_urts.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_URTS_H_
+#define _INCLUDE_SGX_URTS_H_
+
+#include "common/inc/sgx_urts.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_URTS_H_
