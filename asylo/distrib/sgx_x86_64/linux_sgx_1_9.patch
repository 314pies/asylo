# Google's Modifications to Intel's SGX Development Toolkit

## Top-level files added
  * `BUILD` to build with Blaze/Bazel. Some targets use wrappers around
      `make` defined in `sgx_sdk.bzl`.
    - Changed `psw/ae/common/ProtobufSerializer` to work with a Blaze/Bazel-
      controlled dependency instead of the system-installed `protobuf-compiler`.
  * `sgx_sdk.bzl` provides Skylark rules and macros to wrap `make` and provide
    tools to configure and sign enclave binaries with a debug test-only key.
  * `enclave_test_private.pem` is a DEBUG ONLY private key for signing test
    enclaves. It is generated and included in the linux_sgx patch file only for
    reproducible build purposes. A cautious user may generate another one to
    replace it in their Bazel cache or modify the patch file itself to apply
    a different PEM file. We used the following command to generate the PEM:

        openssl genrsa -out enclave_test_private.pem 3072

    The key in `asylo/distrib/linux_sgx_1_9.patch` can be changed to a new
    PEM file (which must be named `enclave_test_private.pem`, since that is what
    the `sgx_sdk.bzl` build rules look for) with the following commands, which
    copy the patch before the PEM, write a new PEM, then copy the patch after
    the old PEM diff:

        OLD=linux_sgx_1_9.patch
        S="+++ enclave_test_private.pem"
        E="+-----END RSA PRIVATE KEY-----"
        START=$(( -2 + $(grep -n "${S}" "${OLD}" | tail -n 1 | sed 's/:.*//') ))
        END=$(( 1 + $(grep -n "${E}" "${OLD}" | tail -n 1 | sed 's/:.*//') ))
        NEW=$(mktemp)
        head "-n${START}" "${OLD}" > "${NEW}"
        diff -u /dev/null enclave_test_private.pem | filterdiff \
          --remove-timestamps >> "${NEW}"
        tail "-n+${END}" "${OLD}" >> "${NEW}"
        mv "${NEW}" "${OLD}"

    `grep` is piped to `tail` to skip finding its own command in this patch
    preamble. `grep -n` adds the line number to the beginning with `:` after, so
    strip off `:` and everything after to get a number to feed to `head` and
    `tail`. The `-2` is for `head` to not print either the starting line or the
    necessary preceding line of `--- /dev/null`. The `1 +` is so `tail` does not
    duplicate the END RSA line.


## Directories added
### `runtime_support/`

Contains headers, functions, and symbols needed by SGX SDK and PSW.

  * `rts_config.h` is for sources that need non standard C library functions,
     e.g., `memset_s`.
  * `sgx_init_string_lib.c` provides a new version of `sgx_init_string_lib`
    because we are using newlib instead of Intel's tlibc.


## Modifications to Intel's SDK release 1.9
### Downstreamed PRs
* [PR168](https://github.com/intel/linux-sgx/pull/168): Add timeout checks to
  play nicer with signals
   - Affected files:
     + `common/inc/internal/oal/uae_oal_api.h`
     + `psw/ae/common/src/NonBlockingUnixCommunicationSocket.cpp`
     + `psw/ae/common/src/SocketTransporter.cpp`
     + `psw/ae/common/src/UnixCommunicationSocket.cpp`
     + `psw/uae_service/linux/Makefile`
     + `psw/uae_service/sgx_uae_service.cpp`
* [PR216](https://github.com/intel/linux-sgx/pull/216): Includes for compiler
  language conformance.
   - Affected files:
     + `platform_info_blob.h` changed to include `aeerror.h`
     + `se_atomic.h` changed to include `stdint.h`
* [PR215](https://github.com/intel/linux-sgx/pull/215): Add
  `sgx_is_enclave_crashed()`.
   - Affected files:
     + `sgx_trts.h` and `trts.cpp` provide `sgx_is_enclave_crashed()` for
       enclave applications to cooperatively abort operations when another
       thread has marked the enclave as crashed.
* [95ea2c21](https://github.com/intel/linux-sgx/commit/95ea2c21a921ceb3851b090f092709c5b08b9b37)
  includes `/* fallthrough */` comments in `tinyxml2.cpp` that are necessary to
  appease `-Wimplicit-fallthrough`.

### Pending PRs
* [PR210](https://github.com/intel/linux-sgx/pull/210): Language conformance to
  resolve conflict with newlib.
    - Affected files:
      + `external/crypto_px/include/ippbase.h`
      + `external/epid/ext/ipp/include/ippbase.h`
      + `external/epid-sdk-3.0.0/ext/ipp/include/ippbase.h`
      + `external/crypto_px/sources/include/cpudef.h`
    - *Details:* Removed definition of reserved symbols `__INT64` and `__UINT64`
      and instead use `int64_t` and `uint64_t` from `<stdint.h>`. A use of
      `__INT64` in `cpudef.h` is changed to use `Ipp64s` from `ippbase.h`.
* [PR217](https://github.com/intel/linux-sgx/pull/217): Red-zone avoidance.
    - Affected files:
      + `trts_pic.S` changes `continue_execution` so that does not store the
        instruction address for resumption in a part of the stack that is likely
        in use.  Otherwise, it stores it at the next stack location, which at
        least OPENSSL_cpuid has in use at the time of CPUID execution,
        corrupting important information.
* [PR143](https://github.com/intel/linux-sgx/pull/143): If `enclave_create` is
  interrupted, return an internal error code.
    - Affected files:
      + `urts/linux/enclave_creator_hw.cpp` returns an internal error code.
      + `common/inc/sgx_error.h` defines an internal error code.
* [PR222](https://github.com/intel/linux-sgx/pull/222): Generate different code
  for user exception handlers in edger8r.
    - Affected files:
      + `sdk/edger8r/linux/Ast.ml`: Represent an exception handler function.
      + `sdk/edger8r/linux/CodeGen.ml`: Produce a new exception handler bit.
      + `sdk/edger8r/linux/Lexer.mll`: Add an exeception_handler token.
      + `sdk/edger8r/linux/Parser.mly`: Add exception_handler to function
        grammar and build a modified AST.
* [PR223](https://github.com/intel/linux-sgx/pull/223): Integrate with edger8r
  exception handler code to provide user handlers.
    - Affected files:
      + `trts_internal.h`
      + `trts_nsp.cpp`

### Non-upstreamed changes
* `sdk/trts/trts_ecall.cpp` added
  `g_ecall_table.ecall_table[ordinal].is_exception` to the check condition of
  g_dyn_entry_table check to allow exception handler ecalls to pass even during
  an ocall of the interrupted frame. This deflakes our signal handling.
* `psw/urts/enclave.h``psw/urts/enclave.cpp` add a method `get_tcs_info` to
  `CEnclave` class to expose the tcs info.
  `sdk/simulation/urtssim/get_state.cpp` added to get the tcs state from tcs
  info.
  `psw/urts/linux/urts.cpp``common/inc/sgx_urts.h` add a method
  `sgx_is_enclave_active` to get whether the simulation enclave is active.
* `buildenv.mk` changed `SE_TRACE_DEBUG` to `SE_TRACE_ERROR` and added
    -Wno-... flags related to excessive warnings for quieter uses of the SDK.
* Static stack size increase.
    - Affected files:
      + `sdk/trts/trts_internal.h`
      + `sdk/trts/linux/trts_pic.h`
      + `common/inc/internal/metadata.h`
    - *Changes:*
      + the first two headers change `STATIC_STACK_SIZE` from `8*100` to `8*1024`
        to avoid crash in asylo signal handler.
      + The third header changes `STACK_SIZE_MIN` from `0x1000` to `0x3000` to
        make sure it's larger than the static stack size.
    - *Detail:* `STATIC_STACK_SIZE` of stack is allocated for each tcs, and when
      an exception is raised, the frame that enters enclave to deal with the
      exception shares the same tcs as the enclave frame being interrupted,
      hence uses the memory directly adjacent. It will overwrite the interrupted
      frame's stack when it overflows. Since the exception handler makes a few
      functions calls to enter enclave to handle the exception, when combined
      with the use of STL containers it's easy to exceed the original stack
      size.
* `sdk/trts/linux/x86_64/setcontext.S` stubs out `ucontext` and
  `__NR_rt_sigprocmask` since we don't have it working yet.
* `external/crypto_px/sources/ippcp/src/pcpbnumimpl.h` and
  `external/crypto_px/sources/ippcp/src/pcphashmd5px.c` remove
  pragma messages that result in excessive and unhelpful output.
* `external/crypto_px/sources/ippcp/src/pcpbnumisc.h` and
  `external/epid/ext/ipp/sources/ippcp/src/pcpbnumisc.h` add `{}` to
  the `FIX_BNU` definition to appease `-Wmisleading-indentation`.
* `external/crypto_px/sources/ippcp/src/pcptool.h` fix include guard typo
--
diff -Nur -x '*.png' -x '*.gif' buildenv.mk buildenv.mk
--- buildenv.mk
+++ buildenv.mk
@@ -51,12 +51,13 @@
 LINUX_PSW_DIR         := $(ROOT_DIR)/psw
 LINUX_SDK_DIR         := $(ROOT_DIR)/sdk
 LINUX_UNITTESTS       := $(ROOT_DIR)/unittests
+RUN_TIME_SUPPORT_DIR  := $(ROOT_DIR)/runtime_support
 
 
 CP    := /bin/cp -f
 MKDIR := mkdir -p
 STRIP := strip
-OBJCOPY := objcopy
+OBJCOPY ?= objcopy
 
 # clean the content of 'INCLUDE' - this variable will be set by vcvars32.bat
 # thus it will cause build error when this variable is used by our Makefile,
@@ -76,7 +77,7 @@
 
 ifdef DEBUG
     COMMON_FLAGS += -ggdb -DDEBUG -UNDEBUG
-    COMMON_FLAGS += -DSE_DEBUG_LEVEL=SE_TRACE_DEBUG
+    COMMON_FLAGS += -DSE_DEBUG_LEVEL=SE_TRACE_ERROR
 else
     COMMON_FLAGS += -O2   -UDEBUG -DNDEBUG
 endif
@@ -85,7 +86,7 @@
     COMMON_FLAGS += -DSE_SIM
 endif
 
-COMMON_FLAGS += -ffunction-sections -fdata-sections
+COMMON_FLAGS += -ffunction-sections -fdata-sections -DTHIRD_PARTY_LINUX_SGX_RUNTIME_RTS_CONFIG_H_
 
 # turn on compiler warnings as much as possible
 COMMON_FLAGS += -Wall -Wextra -Winit-self -Wpointer-arith -Wreturn-type \
@@ -93,6 +94,10 @@
 		-Wmissing-include-dirs -Wfloat-equal -Wundef -Wshadow \
 		-Wcast-align -Wconversion -Wredundant-decls
 
+# disable noisy compiler warnings
+COMMON_FLAGS += -Wno-unknown-pragmas -Wno-conversion -Wno-undef -Wno-unused \
+		-Wno-strict-aliasing -Wno-redundant-decls
+
 # additional warnings flags for C
 CFLAGS += -Wjump-misses-init -Wstrict-prototypes -Wunsuffixed-float-constants
 
@@ -156,7 +161,8 @@
 # When `pie' is enabled, the linker (both BFD and Gold) under Ubuntu 14.04
 # will hide all symbols from dynamic symbol table even if they are marked
 # as `global' in the LD version script.
-ENCLAVE_CFLAGS   = -ffreestanding -nostdinc -fvisibility=hidden -fpie
+ENCLAVE_CFLAGS   = -ffreestanding -nostdinc -fvisibility=hidden -fpie \
+		   -I$(RUN_TIME_SUPPORT_DIR)/
 ENCLAVE_CXXFLAGS = $(ENCLAVE_CFLAGS) -nostdinc++
 ENCLAVE_LDFLAGS  = -Wl,-Bstatic -Wl,-Bsymbolic -Wl,--no-undefined \
                    -Wl,-pie,-eenclave_entry -Wl,--export-dynamic  \
diff -Nur -x '*.png' -x '*.gif' common/inc/internal/metadata.h common/inc/internal/metadata.h
--- common/inc/internal/metadata.h
+++ common/inc/internal/metadata.h
@@ -57,7 +57,7 @@
 #define SSA_NUM_MIN 2
 #define SSA_FRAME_SIZE_MIN 1
 #define SSA_FRAME_SIZE_MAX 2
-#define STACK_SIZE_MIN 0x1000
+#define STACK_SIZE_MIN 0x3000
 #define HEAP_SIZE_MIN 0
 #define DEFAULT_MISC_SELECT 0
 #define DEFAULT_MISC_MASK 0xFFFFFFFF
diff -Nur -x '*.png' -x '*.gif' common/inc/internal/oal/uae_oal_api.h common/inc/internal/oal/uae_oal_api.h
--- common/inc/internal/oal/uae_oal_api.h
+++ common/inc/internal/oal/uae_oal_api.h
@@ -42,6 +42,7 @@
     UAE_OAL_ERROR_UNEXPECTED            ,
     UAE_OAL_ERROR_AESM_UNAVAILABLE      ,
     UAE_OAL_ERROR_TIMEOUT               ,
+    UAE_OAL_ERROR_INVALID               ,
 } uae_oal_status_t;
 
 /*OAL methods from here forward */
diff -Nur -x '*.png' -x '*.gif' common/inc/internal/se_atomic.h common/inc/internal/se_atomic.h
--- common/inc/internal/se_atomic.h
+++ common/inc/internal/se_atomic.h
@@ -32,6 +32,7 @@
 #ifndef _SE_ATOMIC_H_
 #define _SE_ATOMIC_H_
 
+#include <stdint.h>
 
 inline uint32_t se_atomic_inc(volatile uint32_t *mem)
 {
diff -Nur -x '*.png' -x '*.gif' common/inc/sgx_error.h common/inc/sgx_error.h
--- common/inc/sgx_error.h
+++ common/inc/sgx_error.h
@@ -99,6 +99,8 @@
     SGX_ERROR_FILE_FLUSH_FAILED             = SGX_MK_ERROR(0x7008),	/* fflush operation (to disk) failed (only used when no EXXX is returned) */
     SGX_ERROR_FILE_CLOSE_FAILED             = SGX_MK_ERROR(0x7009),	/* fclose operation (to disk) failed (only used when no EXXX is returned) */
 
+    SGX_INTERNAL_ERROR_ENCLAVE_CREATE_INTERRUPTED = SGX_MK_ERROR(0xF001), /* The ioctl for enclave_create unexpectedly failed with EINTR. */
+
 } sgx_status_t;
 
 #endif
diff -Nur -x '*.png' -x '*.gif' common/inc/sgx_trts.h common/inc/sgx_trts.h
--- common/inc/sgx_trts.h
+++ common/inc/sgx_trts.h
@@ -74,6 +74,14 @@
 */
 sgx_status_t SGXAPI sgx_read_rand(unsigned char *rand, size_t length_in_bytes);
 
+/* sgx_is_enclave_crashed()
+ * Return Value:
+ *      1 - the enclave is in a crashed state. Do not allow further processing
+ *          in the enclave, nor allow data to leave the enclave.
+ *      0 - the enclave is not in a crashed state.
+*/
+int SGXAPI sgx_is_enclave_crashed(void);
+
 #ifdef __cplusplus
 }
 #endif
diff -Nur -x '*.png' -x '*.gif' common/inc/sgx_urts.h common/inc/sgx_urts.h
--- common/inc/sgx_urts.h
+++ common/inc/sgx_urts.h
@@ -57,6 +57,8 @@
 
 sgx_status_t SGXAPI sgx_destroy_enclave(const sgx_enclave_id_t enclave_id);
 
+int SGXAPI sgx_is_tcs_active(const sgx_enclave_id_t enclave_id);
+
 #ifdef __cplusplus
 }
 #endif
diff -Nur -x '*.png' -x '*.gif' external/crypto_px/include/ippbase.h external/crypto_px/include/ippbase.h
--- external/crypto_px/include/ippbase.h
+++ external/crypto_px/include/ippbase.h
@@ -32,6 +32,8 @@
 #ifndef __IPPBASE_H__
 #define __IPPBASE_H__
 
+#include <stdint.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -39,13 +41,9 @@
 #if defined( _WIN32 ) || defined ( _WIN64 )
   #define __STDCALL  __stdcall
   #define __CDECL    __cdecl
-  #define __INT64    __int64
-  #define __UINT64    unsigned __int64
 #else
   #define __STDCALL
   #define __CDECL
-  #define __INT64    long long
-  #define __UINT64    unsigned long long
 #endif
 
 #define IPP_PI    ( 3.14159265358979323846 )  /* ANSI C does not support M_PI */
@@ -117,8 +115,8 @@
 typedef signed short   Ipp16s;
 typedef signed int     Ipp32s;
 typedef float          Ipp32f;
-typedef __INT64        Ipp64s;
-typedef __UINT64       Ipp64u;
+typedef int64_t        Ipp64s;
+typedef uint64_t       Ipp64u;
 typedef double         Ipp64f;
 typedef Ipp16s         Ipp16f;
 
diff -Nur -x '*.png' -x '*.gif' external/crypto_px/sources/include/cpudef.h external/crypto_px/sources/include/cpudef.h
--- external/crypto_px/sources/include/cpudef.h
+++ external/crypto_px/sources/include/cpudef.h
@@ -78,7 +78,7 @@
 int __CDECL ownGetFeature( Ipp64u MaskOfFeature );
 int __CDECL ipp_is_avx_extension( void );
 
-__INT64  __CDECL ipp_get_pentium_counter (void);
+Ipp64s  __CDECL ipp_get_pentium_counter (void);
 int __CDECL ipp_is_mmx_extension (void);
 int __CDECL ipp_is_ssx_extension (void);
 int __CDECL ipp_is_wni_extension (void);
diff -Nur -x '*.png' -x '*.gif' external/crypto_px/sources/ippcp/src/pcpbnuimpl.h external/crypto_px/sources/ippcp/src/pcpbnuimpl.h
--- external/crypto_px/sources/ippcp/src/pcpbnuimpl.h
+++ external/crypto_px/sources/ippcp/src/pcpbnuimpl.h
@@ -55,7 +55,6 @@
 #define BNU_CHUNK_MASK        (~(BNU_CHUNK_T)(0))
 
 #if (BNU_CHUNK_BITS == BNU_CHUNK_64BIT)
-   #pragma message ("BNU_CHUNK_BITS = 64 bit")
 #elif (BNU_CHUNK_BITS == BNU_CHUNK_32BIT)
    #pragma message ("BNU_CHUNK_BITS = 32 bit")
 #else
diff -Nur -x '*.png' -x '*.gif' external/crypto_px/sources/ippcp/src/pcpbnumisc.h external/crypto_px/sources/ippcp/src/pcpbnumisc.h
--- external/crypto_px/sources/ippcp/src/pcpbnumisc.h
+++ external/crypto_px/sources/ippcp/src/pcpbnumisc.h
@@ -70,9 +70,9 @@
    for(; __idx<(dstLen); __idx++)    (dst)[__idx] = 0; \
 }
 
-/* fix actual length */
+/* fix actual length; {} is required to build with GCC6 */
 #define FIX_BNU(src,srcLen) \
-   for(; ((srcLen)>1) && (0==(src)[(srcLen)-1]); (srcLen)--)
+   for(; ((srcLen)>1) && (0==(src)[(srcLen)-1]); (srcLen)--){}
 
 
 /* copy and set */
diff -Nur -x '*.png' -x '*.gif' external/crypto_px/sources/ippcp/src/pcphashmd5px.c external/crypto_px/sources/ippcp/src/pcphashmd5px.c
--- external/crypto_px/sources/ippcp/src/pcphashmd5px.c
+++ external/crypto_px/sources/ippcp/src/pcphashmd5px.c
@@ -34,7 +34,6 @@
 #include "pcphash.h"
 #include "pcptool.h"
 
-#pragma message("IPP_ALG_HASH_MD5 enabled")
 
 
 /*
diff -Nur -x '*.png' -x '*.gif' external/crypto_px/sources/ippcp/src/pcptool.h external/crypto_px/sources/ippcp/src/pcptool.h
--- external/crypto_px/sources/ippcp/src/pcptool.h
+++ external/crypto_px/sources/ippcp/src/pcptool.h
@@ -29,7 +29,7 @@
 *
 */
 
-#if !defined(_PC_TOOL_H)
+#if !defined(_CP_TOOL_H)
 #define _CP_TOOL_H
 
 /* copy data block */
diff -Nur -x '*.png' -x '*.gif' external/epid/ext/ipp/include/ippbase.h external/epid/ext/ipp/include/ippbase.h
--- external/epid/ext/ipp/include/ippbase.h
+++ external/epid/ext/ipp/include/ippbase.h
@@ -25,6 +25,8 @@
 #ifndef __IPPBASE_H__
 #define __IPPBASE_H__
 
+#include <stdint.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -32,13 +34,9 @@
 #if defined( _WIN32 ) || defined ( _WIN64 )
   #define __STDCALL  __stdcall
   #define __CDECL    __cdecl
-  #define __INT64    __int64
-  #define __UINT64    unsigned __int64
 #else
   #define __STDCALL
   #define __CDECL
-  #define __INT64    long long
-  #define __UINT64    unsigned long long
 #endif
 
 #define IPP_PI    ( 3.14159265358979323846 )  /* ANSI C does not support M_PI */
@@ -110,8 +108,8 @@
 typedef signed short   Ipp16s;
 typedef signed int     Ipp32s;
 typedef float          Ipp32f;
-typedef __INT64        Ipp64s;
-typedef __UINT64       Ipp64u;
+typedef int64_t        Ipp64s;
+typedef uint64_t       Ipp64u;
 typedef double         Ipp64f;
 typedef Ipp16s         Ipp16f;
 
diff -Nur -x '*.png' -x '*.gif' external/epid/ext/ipp/sources/ippcp/src/pcpbnumisc.h external/epid/ext/ipp/sources/ippcp/src/pcpbnumisc.h
--- external/epid/ext/ipp/sources/ippcp/src/pcpbnumisc.h
+++ external/epid/ext/ipp/sources/ippcp/src/pcpbnumisc.h
@@ -75,9 +75,9 @@
 }
 #endif
 
-/* fix actual length */
+/* fix actual length; {} is required to build with GCC6 */
 #define FIX_BNU(src,srcLen) \
-   for(; ((srcLen)>1) && (0==(src)[(srcLen)-1]); (srcLen)--)
+   for(; ((srcLen)>1) && (0==(src)[(srcLen)-1]); (srcLen)--){}
 
 
 /* copy and set */
diff -Nur -x '*.png' -x '*.gif' external/epid-sdk-3.0.0/ext/ipp/include/ippbase.h external/epid-sdk-3.0.0/ext/ipp/include/ippbase.h
--- external/epid-sdk-3.0.0/ext/ipp/include/ippbase.h
+++ external/epid-sdk-3.0.0/ext/ipp/include/ippbase.h
@@ -25,6 +25,8 @@
 #ifndef __IPPBASE_H__
 #define __IPPBASE_H__
 
+#include <stdint.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -32,13 +34,9 @@
 #if defined( _WIN32 ) || defined ( _WIN64 )
   #define __STDCALL  __stdcall
   #define __CDECL    __cdecl
-  #define __INT64    __int64
-  #define __UINT64    unsigned __int64
 #else
   #define __STDCALL
   #define __CDECL
-  #define __INT64    long long
-  #define __UINT64    unsigned long long
 #endif
 
 #define IPP_PI    ( 3.14159265358979323846 )  /* ANSI C does not support M_PI */
@@ -110,8 +108,8 @@
 typedef signed short   Ipp16s;
 typedef signed int     Ipp32s;
 typedef float          Ipp32f;
-typedef __INT64        Ipp64s;
-typedef __UINT64       Ipp64u;
+typedef int64_t        Ipp64s;
+typedef uint64_t       Ipp64u;
 typedef double         Ipp64f;
 typedef Ipp16s         Ipp16f;
 
diff -Nur -x '*.png' -x '*.gif' .gitignore .gitignore
--- .gitignore
+++ .gitignore
@@ -1,19 +0,0 @@
-#object file
-*.o
-
-#library
-*.a
-
-#share object
-*.so
-*.so.*
-
-#generated proxy
-*_u.c
-*_u.h
-*_t.c
-*_t.h
-
-#output files
-/build/
-/linux/installer/bin/*.bin
diff -Nur -x '*.png' -x '*.gif' psw/ae/aesm_service/source/upse/platform_info_blob.h psw/ae/aesm_service/source/upse/platform_info_blob.h
--- psw/ae/aesm_service/source/upse/platform_info_blob.h
+++ psw/ae/aesm_service/source/upse/platform_info_blob.h
@@ -35,6 +35,7 @@
 #include <stdint.h>
 #include "epid_pve_type.h"
 #include "sgx_tcrypto.h"
+#include "aeerror.h"
 
 
 #pragma pack(push, 1)
diff -Nur -x '*.png' -x '*.gif' psw/ae/common/inc/IAEMessage.h psw/ae/common/inc/IAEMessage.h
--- psw/ae/common/inc/IAEMessage.h
+++ psw/ae/common/inc/IAEMessage.h
@@ -37,7 +37,7 @@
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
 #pragma GCC diagnostic ignored "-Wconversion"
-#include <messages.pb.h>
+#include "psw/ae/common/proto/messages.pb.h"
 #pragma GCC diagnostic pop
 
 struct AEMessage{
diff -Nur -x '*.png' -x '*.gif' psw/ae/common/src/NonBlockingUnixCommunicationSocket.cpp psw/ae/common/src/NonBlockingUnixCommunicationSocket.cpp
--- psw/ae/common/src/NonBlockingUnixCommunicationSocket.cpp
+++ psw/ae/common/src/NonBlockingUnixCommunicationSocket.cpp
@@ -43,6 +43,7 @@
 #include <errno.h>
 #include <sys/epoll.h>
 #include <string.h>
+#include <se_trace.h>
 
 NonBlockingUnixCommunicationSocket::~NonBlockingUnixCommunicationSocket()
 {
@@ -136,6 +137,10 @@
     do{
         //try a direct read (maybe all data is available already)
         step = read(mSocket, recBuf, length);
+        if (step == -1 && errno == EINTR && CheckForTimeout() == false) {
+          SE_TRACE_WARNING("read is interrupted by signal\n");
+          continue;
+        }
         if (step == -1 && errno != EAGAIN)
         {
             errorDetected = true;
@@ -154,7 +159,10 @@
         }
 
         //wait for events
-        eventNum = epoll_wait(mEpoll, mEvents, MAX_EVENTS, epollTimeout);    
+        do {
+            eventNum = epoll_wait(mEpoll, mEvents, MAX_EVENTS, epollTimeout);
+        } while (eventNum == -1 && errno == EINTR && CheckForTimeout() == false);
+
         if (eventNum == -1)
         {
             errorDetected = true;
@@ -253,6 +261,12 @@
         remaining = maxLength - totalRead;        
 
         step = read(mSocket, buffer + totalRead,  (remaining > chunkSize ? chunkSize : remaining));
+
+        if (step == -1 && errno == EINTR && CheckForTimeout() == false) {
+            SE_TRACE_WARNING("read is interrupted by signal\n");
+            continue;
+        }
+
         if (step == -1)
         {
             if (errno != EAGAIN)
@@ -291,6 +305,10 @@
     do
     {
         step = write(mSocket, data + total_write, length - total_write);
+        if(step == -1 && errno == EINTR && CheckForTimeout() == false) {
+             SE_TRACE_WARNING("write is interrupted by signal\n");
+             continue;
+        }
 
         if (step == -1 && errno != EAGAIN)
         {
@@ -344,7 +362,9 @@
             }
         }
 
-        eventNum = epoll_wait(mEpoll, mEvents, MAX_EVENTS, epollTimeout);
+        do {
+            eventNum = epoll_wait(mEpoll, mEvents, MAX_EVENTS, epollTimeout);
+        } while (eventNum == -1 && errno == EINTR && CheckForTimeout() == false);
         if (eventNum == -1)
         {
             errorDetected = true;
diff -Nur -x '*.png' -x '*.gif' psw/ae/common/src/SocketTransporter.cpp psw/ae/common/src/SocketTransporter.cpp
--- psw/ae/common/src/SocketTransporter.cpp
+++ psw/ae/common/src/SocketTransporter.cpp
@@ -82,7 +82,7 @@
 uae_oal_status_t SocketTransporter::transact(IAERequest* request, IAEResponse* response, uint32_t timeout)
 {
     if (request == NULL || response == NULL)
-        return UAE_OAL_ERROR_UNEXPECTED;
+        return UAE_OAL_ERROR_INVALID;
 
 
     ICommunicationSocket* communicationSocket = mSocketFactory->NewCommunicationSocket();
diff -Nur -x '*.png' -x '*.gif' psw/ae/common/src/UnixCommunicationSocket.cpp psw/ae/common/src/UnixCommunicationSocket.cpp
--- psw/ae/common/src/UnixCommunicationSocket.cpp
+++ psw/ae/common/src/UnixCommunicationSocket.cpp
@@ -34,9 +34,10 @@
 #include <sys/socket.h>
 #include <sys/un.h>
 #include <stdlib.h>
-
+#include <errno.h>
 #include <IAERequest.h>
 #include <IAEResponse.h>
+#include <se_trace.h>
 
 #include <UnixCommunicationSocket.h>
 
@@ -146,6 +147,10 @@
     ssize_t written = 0;
     do {
         ssize_t step = write(mSocket, data+written, length-written);
+        if (step == -1 && errno == EINTR && CheckForTimeout() == false) {
+            SE_TRACE_WARNING("write was interrupted by signal\n");
+            continue;
+        }
 
         if (step < 0 || CheckForTimeout())
         {
@@ -174,6 +179,10 @@
 
     do {
         ssize_t step = read(mSocket, recBuf + total_read, length - total_read);
+        if (step == -1 && errno == EINTR && CheckForTimeout() == false) {
+            SE_TRACE_WARNING("read was interrupted by signal\n");
+            continue;
+        }
 
         //check connection closed by peer
         if (step <= 0 || CheckForTimeout())
diff -Nur -x '*.png' -x '*.gif' psw/uae_service/linux/Makefile psw/uae_service/linux/Makefile
--- psw/uae_service/linux/Makefile
+++ psw/uae_service/linux/Makefile
@@ -62,8 +62,9 @@
 EXTERNAL_LIB += -lprotobuf 
  
 vpath %.cpp .. $(COMMON_DIR)/src  $(IPC_COMMON_SRC_DIR) $(IPC_COMMON_PROTO_DIR) $(UAE_SRC_DIR) $(AE_COMMON_DIR)
+vpath %.c $(COMMON_DIR)/src
 
-
+C_SRC    := se_trace.c
 
 IPC_SRC  := AECloseSessionRequest.cpp    \
              AEGetQuoteResponse.cpp \
@@ -110,7 +111,7 @@
              uae_service_version.cpp \
              uae_service_assert.cpp
 
-OBJ := $(SRC:.cpp=.o) $(IPC_SRC:.cpp=.o)  $(PROTOBUF_SRC:.cc=.o) 
+OBJ := $(C_SRC:.c=.o) $(SRC:.cpp=.o) $(IPC_SRC:.cpp=.o)  $(PROTOBUF_SRC:.cc=.o) 
 
 LDUFLAGS:= -pthread -L$(BUILD_DIR)
 LDUFLAGS += -Wl,--version-script=uae_service.lds -Wl,--gc-sections
@@ -151,6 +152,8 @@
 	$(CXX) $(filter-out -Wshadow, $(CXXFLAGS)) -c $< -o $@
 %.o :%.cpp
 	$(CXX) $(CXXFLAGS) $(INCLUDE) -c $< -o $@
+%.o :%.c
+	$(CC) $(CFLAGS) $(INCLUDE) -Werror -fPIC -c $< -o $@
 
 $(BUILD_DIR):
 	@$(MKDIR) $@
diff -Nur -x '*.png' -x '*.gif' psw/uae_service/sgx_uae_service.cpp psw/uae_service/sgx_uae_service.cpp
--- psw/uae_service/sgx_uae_service.cpp
+++ psw/uae_service/sgx_uae_service.cpp
@@ -623,6 +623,9 @@
         case UAE_OAL_ERROR_TIMEOUT:
             retVal = SGX_ERROR_SERVICE_TIMEOUT;
             break;
+        case UAE_OAL_ERROR_INVALID:
+            retVal = SGX_ERROR_INVALID_PARAMETER;
+            break;
         default:
             retVal = SGX_ERROR_UNEXPECTED;
     }
diff -Nur -x '*.png' -x '*.gif' psw/uae_service/uae_wrapper/src/AEServicesImpl.cpp psw/uae_service/uae_wrapper/src/AEServicesImpl.cpp
--- psw/uae_service/uae_wrapper/src/AEServicesImpl.cpp
+++ psw/uae_service/uae_wrapper/src/AEServicesImpl.cpp
@@ -54,7 +54,7 @@
 {
     if(request->check() == false)
     {
-        return UAE_OAL_ERROR_UNEXPECTED;
+        return UAE_OAL_ERROR_INVALID;
     }
     uae_oal_status_t ipc_status = mTransporter->transact(request, response, timeout_msec);
 
diff -Nur -x '*.png' -x '*.gif' psw/urts/enclave.cpp psw/urts/enclave.cpp
--- psw/urts/enclave.cpp
+++ psw/urts/enclave.cpp
@@ -215,6 +215,15 @@
     return &m_enclave_info;
 }
 
+#ifdef SE_SIM
+tcs_t *CEnclave::get_tcs_info()
+{
+  CTrustThread *trust_thread = get_tcs();
+  if (!trust_thread)
+    return NULL;
+  return trust_thread->get_tcs();
+}
+#endif
 
 CTrustThread * CEnclave::get_tcs()
 {
diff -Nur -x '*.png' -x '*.gif' psw/urts/enclave.h psw/urts/enclave.h
--- psw/urts/enclave.h
+++ psw/urts/enclave.h
@@ -75,6 +75,9 @@
     void pop_ocall_frame(CTrustThread *trust_thread);
     bool update_trust_thread_debug_flag(void*, uint8_t);
     bool update_debug_flag(uint8_t);
+#ifdef SE_SIM
+    tcs_t *get_tcs_info();
+#endif
 private:
     CTrustThread * get_tcs();
     void put_tcs(CTrustThread *trust_thread);
diff -Nur -x '*.png' -x '*.gif' psw/urts/linux/enclave_creator_hw.cpp psw/urts/linux/enclave_creator_hw.cpp
--- psw/urts/linux/enclave_creator_hw.cpp
+++ psw/urts/linux/enclave_creator_hw.cpp
@@ -55,7 +55,6 @@
 EnclaveCreator* g_enclave_creator = &g_enclave_creator_hw;
 static uint64_t g_eid = 0x1;
 
-
 EnclaveCreatorHW::EnclaveCreatorHW():
     m_hdevice(-1),
     m_sig_registered(false)
@@ -141,13 +140,16 @@
     {
         munmap((void*)((size_t)secs->base + secs->size), (size_t)(enclave_base) + (size_t)secs->size - (size_t)(secs->base));
     }
-    
+
     struct sgx_enclave_create param = {0};
     param.src = (uintptr_t)(secs);
     ret = ioctl(m_hdevice, SGX_IOC_ENCLAVE_CREATE, &param);
-    if(ret) {
+    if (ret) {
+        if(ret == -1 && errno == EINTR) {
+            return SGX_INTERNAL_ERROR_ENCLAVE_CREATE_INTERRUPTED;  // Allow the user to retry.
+        }
         SE_TRACE(SE_TRACE_WARNING, "\nISGX_IOCTL_ENCLAVE_CREATE failed: errno = %d\n", errno);
-        return error_driver2urts(ret);
+        return ret;
     }
     *enclave_id = se_atomic_inc64(&g_eid);
     *start_addr = secs->base;
@@ -175,13 +177,13 @@
     addp.secinfo = reinterpret_cast<uintptr_t>(const_cast<sec_info_t *>(&sinfo));
     if(((1<<DoEEXTEND) & attr))
         addp.mrmask |= 0xFFFF;
-    
+
     ret = ioctl(m_hdevice, SGX_IOC_ENCLAVE_ADD_PAGE, &addp);
     if(ret) {
         SE_TRACE(SE_TRACE_WARNING, "\nAdd Page - %p to %p... FAIL\n", source, rva);
-        return error_driver2urts(ret);
+        return ret;
     }
-   
+
     return SGX_SUCCESS;
 }
 
diff -Nur -x '*.png' -x '*.gif' psw/urts/linux/enter_enclave.S psw/urts/linux/enter_enclave.S
--- psw/urts/linux/enter_enclave.S
+++ psw/urts/linux/enter_enclave.S
@@ -38,7 +38,7 @@
 .text
 DECLARE_GLOBAL_FUNC __morestack
 
-__morestack:
+.__morestack:
 EENTER_PROLOG
     movl    frame_arg1, %edi                    /* fn */
 #if defined(__x86_64__)
diff -Nur -x '*.png' -x '*.gif' psw/urts/linux/urts.cpp psw/urts/linux/urts.cpp
--- psw/urts/linux/urts.cpp
+++ psw/urts/linux/urts.cpp
@@ -29,7 +29,8 @@
  *
  */
 
-
+#include "arch.h"
+#include "enclave.h"
 #include "sgx_error.h"
 #include "sgx_urts.h"
 #include "se_types.h"
@@ -70,3 +71,20 @@
 
     return ret;
 }
+
+extern "C" int is_tcs_sim_active(const tcs_t *tcs);
+
+extern "C" int sgx_is_tcs_active(const sgx_enclave_id_t enclave_id)
+{
+// In the non-sim case, tcs cannot be active because untrusted code cannot run
+// when it is active.
+#ifdef SE_SIM
+  CEnclave* enclave = CEnclavePool::instance()->get_enclave(enclave_id);
+  if (enclave)
+  {
+    tcs_t *tcs = enclave->get_tcs_info();
+    return is_tcs_sim_active(tcs);
+  }
+#endif
+  return 0;
+}
diff -Nur -x '*.png' -x '*.gif' psw/urts/loader.cpp psw/urts/loader.cpp
--- psw/urts/loader.cpp
+++ psw/urts/loader.cpp
@@ -46,7 +46,6 @@
 #include <assert.h>
 #include <vector>
 #include <algorithm>
-#define __STDC_FORMAT_MACROS
 #include <inttypes.h>
 #include <sys/mman.h>
 
diff -Nur -x '*.png' -x '*.gif' psw/urts/parser/binparser.h psw/urts/parser/binparser.h
--- psw/urts/parser/binparser.h
+++ psw/urts/parser/binparser.h
@@ -42,7 +42,6 @@
 #include <vector>
 #include <string>
 using std::vector;
-using std::string;
 
 #define ENCLAVE_MAX_SIZE_32 0xffffffff
 #define ENCLAVE_MAX_SIZE_64 0x1fffffffff
diff -Nur -x '*.png' -x '*.gif' psw/urts/parser/elfparser.cpp psw/urts/parser/elfparser.cpp
--- psw/urts/parser/elfparser.cpp
+++ psw/urts/parser/elfparser.cpp
@@ -181,7 +181,7 @@
  * We only need to search `.dynsym' for undefined symbols.
  */
 bool check_symbol_table(const ElfW(Ehdr) *elf_hdr, const ElfW(Dyn) *dyn_info,
-                        map<string, uint64_t>& sym_table)
+                        map<std::string, uint64_t>& sym_table)
 {
     const ElfW(Shdr) *sh_symtab = get_section_by_addr(elf_hdr, dyn_info[DT_SYMTAB].d_un.d_ptr);
 
@@ -242,7 +242,7 @@
     // If the enclave if compiled/linked with -fpie/-pie, and setting the
     // enclave entry to `enclave_entry', the `st_name' for `enclave_entry'
     // will be 0 in `.dynsym'.
-    map<string, uint64_t>::const_iterator it = sym_table.find("enclave_entry");
+    map<std::string, uint64_t>::const_iterator it = sym_table.find("enclave_entry");
     if (it == sym_table.end())
     {
         sym_table["enclave_entry"] = (uint64_t)elf_hdr->e_entry;
@@ -681,7 +681,7 @@
 
 uint64_t ElfParser::get_symbol_rva(const char* name) const
 {
-    map<string, uint64_t>::const_iterator it = m_sym_table.find(name);
+    map<std::string, uint64_t>::const_iterator it = m_sym_table.find(name);
     if (it != m_sym_table.end())
         return it->second;
     else
diff -Nur -x '*.png' -x '*.gif' psw/urts/parser/elfparser.h psw/urts/parser/elfparser.h
--- psw/urts/parser/elfparser.h
+++ psw/urts/parser/elfparser.h
@@ -40,7 +40,6 @@
 #include <map>
 
 using std::map;
-using std::string;
 
 class ElfParser : public BinParser, private Uncopyable {
 public:
@@ -101,7 +100,7 @@
     ElfW(Dyn)           m_dyn_info[DT_NUM + DT_ADDRNUM];
 
     // A map from symbol name to its RVA
-    map<string, uint64_t> m_sym_table;
+    map<std::string, uint64_t> m_sym_table;
 };
 
 #endif
diff -Nur -x '*.png' -x '*.gif' sdk/edger8r/linux/Ast.ml sdk/edger8r/linux/Ast.ml
--- sdk/edger8r/linux/Ast.ml
+++ sdk/edger8r/linux/Ast.ml
@@ -144,6 +144,11 @@
   | UnionDef  of struct_def
   | EnumDef   of enum_def
 
+(* List of errno values to translate between host and enclave. *)
+type errno_list_type = {
+  errnos: string list;
+}
+
 (* Function declaration. *)
 type func_decl = {
   fname : string;       (* function name. *)
@@ -159,6 +164,7 @@
 type trusted_func = {
   tf_fdecl   : func_decl;
   tf_is_priv : bool;
+  tf_is_exception_handler : bool;
 }
 
 type untrusted_func = {
@@ -182,6 +188,7 @@
 type expr =
   | Interface of enclave_func list
   | Composite of composite_type
+  | ErrnoList of errno_list_type
   | Importing of import_decl
   | Include   of string
 
diff -Nur -x '*.png' -x '*.gif' sdk/edger8r/linux/CodeGen.ml sdk/edger8r/linux/CodeGen.ml
--- sdk/edger8r/linux/CodeGen.ml
+++ sdk/edger8r/linux/CodeGen.ml
@@ -46,6 +46,7 @@
   include_list : string list;
   import_exprs : Ast.import_decl list;
   comp_defs    : Ast.composite_type list;
+  errno_list   : Ast.errno_list_type list;
   tfunc_decls  : Ast.trusted_func   list;
   ufunc_decls  : Ast.untrusted_func list;
 }
@@ -61,6 +62,7 @@
     include_list = [];
     import_exprs = [];
     comp_defs    = [];
+    errno_list   = [];
     tfunc_decls  = [];
     ufunc_decls  = []; }
 
@@ -70,6 +72,9 @@
 let is_priv_ecall (tf: Ast.trusted_func) =
   tf.Ast.tf_is_priv
 
+let is_exception_ecall (tf: Ast.trusted_func) =
+  tf.Ast.tf_is_exception_handler
+
 let get_uf_fname (uf: Ast.untrusted_func) =
   uf.Ast.uf_fdecl.Ast.fname
 
@@ -85,6 +90,9 @@
 let tf_list_to_priv_list (tfs: Ast.trusted_func list) =
   List.map is_priv_ecall tfs
 
+let tf_list_to_exception_list (tfs: Ast.trusted_func list) =
+  List.map is_exception_ecall tfs
+
 (* Get a list of names of all private ECALLs *)
 let get_priv_ecall_names (tfs: Ast.trusted_func list) =
   List.filter is_priv_ecall tfs |> List.map get_tf_fname
@@ -104,11 +112,13 @@
   let ac_include_list = ref [] in
   let ac_import_exprs = ref [] in
   let ac_comp_defs = ref [] in
+  let ac_errno_list = ref [] in
   let ac_tfunc_decls = ref [] in
   let ac_ufunc_decls = ref [] in
     List.iter (fun ex ->
       match ex with
           Ast.Composite x -> ac_comp_defs := x :: !ac_comp_defs
+        | Ast.ErrnoList x -> ac_errno_list := x :: !ac_errno_list
         | Ast.Include   x -> ac_include_list := x :: !ac_include_list
         | Ast.Importing x -> ac_import_exprs := x :: !ac_import_exprs
         | Ast.Interface xs ->
@@ -124,6 +134,7 @@
       include_list = List.rev !ac_include_list;
       import_exprs = List.rev !ac_import_exprs;
       comp_defs    = List.rev !ac_comp_defs;
+      errno_list   = List.rev !ac_errno_list;
       tfunc_decls  = List.rev !ac_tfunc_decls;
       ufunc_decls  = List.rev !ac_ufunc_decls; }
 
@@ -306,6 +317,62 @@
       | Ast.UnionDef  u -> mk_union_decl  (gen_member_list u.Ast.mlist) u.Ast.sname
       | Ast.EnumDef   e -> mk_enum_def    e
 
+(* Generate the internal errno enum definition. *)
+let gen_errno_enum (el: Ast.errno_list_type list) =
+  let all_errnos = List.fold_left (fun acc l -> acc @ l.Ast.errnos) [] el
+  in
+  let all_sorted = List.sort_uniq compare all_errnos
+  in
+  let errno_list = List.fold_left (fun acc name ->
+                                    acc ^ "\tSGX_ERRNO_" ^ name ^ ",\n")
+                                  "" all_sorted
+  in
+    if all_errnos = [] then "" else
+      sprintf "enum _sgx_errno_bridge_t {\n%s} sgx_errno_bridge_t;\n" errno_list
+
+(* Generate the function to convert errno values to the internal enum. *)
+let gen_errno_to_conv (el: Ast.errno_list_type list) =
+  let all_errnos = List.fold_left (fun acc l -> acc @ l.Ast.errnos) [] el
+  in
+  let all_sorted = List.sort_uniq compare all_errnos
+  in
+  let errno_switch =
+    "\tswitch(value)\n\t{\n" ^
+    List.fold_left (fun acc name ->
+                     acc ^ "\t\tcase " ^ name ^
+                     ":\n\t\t\tvalue = SGX_ERRNO_" ^ name ^
+                     ";\n\t\t\tbreak;\n")
+                   "" all_sorted ^
+    "\t\tdefault:\n\t\t\tvalue |= 0x8000;\n\t\t\tbreak;\n\t}\n"
+    (* The above 0x8000 serves two purposes
+     * 1. Ensures that no host errno values can colide with our enum.
+     *  * Assumes < 32k errno values in enum.
+     * 2. Provides a debugging aide to indicate that errno is host-relative.
+     *)
+  in
+    if all_errnos = [] then "" else
+      sprintf "static int bridge_translate_errno_to_internal(int value)\n{\n%s\
+        \treturn value;\n}\n" errno_switch
+
+(* Generate the function to convert errno values from the internal enum. *)
+let gen_errno_from_conv (el: Ast.errno_list_type list) =
+  let all_errnos = List.fold_left (fun acc l -> acc @ l.Ast.errnos) [] el
+  in
+  let all_sorted = List.sort_uniq compare all_errnos
+  in
+  let errno_switch =
+    "\tswitch(value)\n\t{\n" ^
+    List.fold_left (fun acc name ->
+                      acc ^ "\t\tcase SGX_ERRNO_" ^ name ^
+                      ":\n\t\t\tvalue = " ^ name ^
+                      ";\n\t\t\tbreak;\n")
+                    "" all_sorted ^
+    "\t}\n"
+  in
+    if all_errnos = [] then "" else
+      sprintf "static int bridge_translate_errno_from_internal(int value)\n{\n%s\
+        \treturn value;\n}\n" errno_switch
+
 (* Generate a list of '#include' *)
 let gen_include_list (xs: string list) =
   List.fold_left (fun acc s -> acc ^ sprintf "#include \"%s\"\n" s) "" xs
@@ -362,15 +429,23 @@
 
 (* ---------------------------------------------------------------------- *)
 
+let fold_left3 f arg a b c =
+  let rec loop arg = function
+    | x::xs, y::ys, z::zs -> loop(f arg x y z) (xs, ys, zs)
+    | [], [], [] -> arg
+  in
+  loop arg (a, b, c)
+
 (* `gen_ecall_table' is used to generate ECALL table with the following form:
     SGX_EXTERNC const struct {
        size_t nr_ecall;    /* number of ECALLs */
        struct {
            void   *ecall_addr;
            uint8_t is_priv;
+           uint8_t is_exception;
        } ecall_table [nr_ecall];
    } g_ecall_table = {
-       2, { {sgx_foo, 1}, {sgx_bar, 0} }
+       2, { {sgx_foo, 1, 0}, {sgx_bar, 0, 1} }
    };
 *)
 let gen_ecall_table (tfs: Ast.trusted_func list) =
@@ -378,18 +453,19 @@
   let ecall_table_size = List.length tfs in
   let trusted_fds = tf_list_to_fd_list tfs in
   let priv_bits = tf_list_to_priv_list tfs in
+  let exception_bits = tf_list_to_exception_list tfs in
   let tbridge_names = List.map (fun (fd: Ast.func_decl) ->
                                   mk_tbridge_name fd.Ast.fname) trusted_fds in
   let ecall_table =
     let bool_to_int b = if b then 1 else 0 in
     let inner_table =
-      List.fold_left2 (fun acc s b ->
-        sprintf "%s\t\t{(void*)(uintptr_t)%s, %d},\n" acc s (bool_to_int b)) "" tbridge_names priv_bits
+      fold_left3 (fun acc s is_priv is_exception_handler ->
+        sprintf "%s\t\t{(void*)(uintptr_t)%s, %d, %d},\n" acc s (bool_to_int is_priv) (bool_to_int is_exception_handler)) "" tbridge_names priv_bits exception_bits
     in "\t{\n" ^ inner_table ^ "\t}\n"
   in
     sprintf "SGX_EXTERNC const struct {\n\
 \tsize_t nr_ecall;\n\
-\tstruct {void* ecall_addr; uint8_t is_priv;} ecall_table[%d];\n\
+\tstruct {void* ecall_addr; uint8_t is_priv; uint8_t is_exception;} ecall_table[%d];\n\
 } %s = {\n\
 \t%d,\n\
 %s};\n" ecall_table_size
@@ -528,7 +604,7 @@
 #include <wchar.h>\n\
 #include <stddef.h>\n\
 #include <string.h>\n\
-#include \"sgx_edger8r.h\" /* for sgx_satus_t etc. */\n" in
+#include \"sgx_edger8r.h\" /* for sgx_status_t etc. */\n" in
     grd_hdr ^ inc_exp ^ "\n" ^ inclist ^ "\n" ^ common_macros
 
 let ms_writer out_chan ec =
@@ -682,12 +758,18 @@
                                acc ^ ", " ^ gen_parm_str pty dlr) p0 ps)
 
 (* Generate untrusted bridge code for a given untrusted function. *)
-let gen_func_ubridge (file_shortnm: string) (ufunc: Ast.untrusted_func) =
+let gen_func_ubridge (file_shortnm: string) (ufunc: Ast.untrusted_func) (conv_errno: bool) =
   let fd = ufunc.Ast.uf_fdecl in
   let propagate_errno = ufunc.Ast.uf_propagate_errno in
   let func_open = sprintf "%s\n{\n" (mk_ubridge_proto file_shortnm fd.Ast.fname) in
   let func_close = "\treturn SGX_SUCCESS;\n}\n" in
-  let set_errno = if propagate_errno then "\tms->ocall_errno = errno;" else "" in
+  let set_errno =
+    if propagate_errno then "\tms->ocall_errno = " ^
+      if conv_errno then
+        "bridge_translate_errno_to_internal(errno);"
+      else
+        "errno;"
+    else "" in
   let ms_struct_name = mk_ms_struct_name fd.Ast.fname in
   let declare_ms_ptr = sprintf "%s* %s = SGX_CAST(%s*, %s);"
                                ms_struct_name
@@ -1135,12 +1217,12 @@
       in
         sprintf "%s%s%s\t%s\n\t%s\n%s" func_open local_vars dummy_var check_pms invoke_func func_close
     else
-      sprintf "%s\t%s\n%s\n%s%s%s\n%s\t%s\n%s\n%s\n%s"
+      sprintf "%s%s\t%s\n%s\n%s%s\n%s\t%s\n%s\n%s\n%s"
         func_open
+        (mk_check_pms fd.Ast.fname)  (* check |pms| before using it *)
         declare_ms_ptr
         local_vars
         (gen_check_tbridge_length_overflow fd.Ast.plist)
-        (mk_check_pms fd.Ast.fname)
         (gen_check_tbridge_ptr_parms fd.Ast.plist)
         (gen_parm_ptr_direction_pre fd.Ast.plist)
         (if fd.Ast.rtype <> Ast.Void then update_retval else invoke_func)
@@ -1243,7 +1325,7 @@
      List.fold_left (fun acc s -> acc ^ s) s1 do_gen_ocalloc_block
   
 (* Generate trusted proxy code for a given untrusted function. *)
-let gen_func_tproxy (ufunc: Ast.untrusted_func) (idx: int) =
+let gen_func_tproxy (ufunc: Ast.untrusted_func) (idx: int) (conv_errno: bool) =
   let fd = ufunc.Ast.uf_fdecl in
   let propagate_errno = ufunc.Ast.uf_propagate_errno in
   let func_open = sprintf "%s\n{\n" (gen_tproxy_proto fd) in
@@ -1264,7 +1346,13 @@
                              Ast.PTVal _ -> acc
                | Ast.PTPtr(ty, attr) -> acc ^ copy_memory attr declr) "" plist in
 
-  let set_errno = if propagate_errno then "\terrno = ms->ocall_errno;" else "" in
+  let set_errno =
+    if propagate_errno then "\terrno = " ^
+      if conv_errno then
+        "bridge_translate_errno_from_internal(ms->ocall_errno);"
+      else
+        "ms->ocall_errno;"
+    else "" in
   let func_close = sprintf "%s%s\n%s%s\n"
                            (handle_out_ptr fd.Ast.plist)
                            set_errno
@@ -1322,12 +1410,16 @@
       (tf_list_to_fd_list ec.tfunc_decls)
       (Util.mk_seq 0 (List.length ec.tfunc_decls - 1))
   in
+  let errno_enum = gen_errno_enum ec.errno_list in
+  let errno_conv = gen_errno_to_conv ec.errno_list in
   let ubridge_list =
-    List.map (fun fd -> gen_func_ubridge ec.file_shortnm fd)
+    List.map (fun fd -> gen_func_ubridge ec.file_shortnm fd (errno_enum <> ""))
       (ec.ufunc_decls) in
   let out_chan = open_out code_fname in
     output_string out_chan (include_hd ^ include_errno ^ "\n");
     ms_writer out_chan ec;
+    output_string out_chan (errno_enum ^ "\n");
+    output_string out_chan (errno_conv ^ "\n");
     List.iter (fun s -> output_string out_chan (s ^ "\n")) ubridge_list;
     output_string out_chan (gen_ocall_table ec);
     List.iter (fun s -> output_string out_chan (s ^ "\n")) uproxy_list;
@@ -1358,14 +1450,18 @@
     List.map (fun tfd -> gen_func_tbridge tfd dummy_var) trusted_fds in
   let ecall_table = gen_ecall_table ec.tfunc_decls in
   let entry_table = gen_entry_table ec in
+  let errno_enum = gen_errno_enum ec.errno_list in
+  let errno_conv = gen_errno_from_conv ec.errno_list in
   let tproxy_list = List.map2
-                      (fun fd idx -> gen_func_tproxy fd idx)
+                      (fun fd idx -> gen_func_tproxy fd idx (errno_enum <> ""))
                       (ec.ufunc_decls)
                       (Util.mk_seq 0 (List.length ec.ufunc_decls - 1)) in
   let out_chan = open_out code_fname in
     output_string out_chan (include_hd ^ "\n");
     ms_writer out_chan ec;
     List.iter (fun s -> output_string out_chan (s ^ "\n")) tbridge_list;
+    output_string out_chan (errno_enum ^ "\n");
+    output_string out_chan (errno_conv ^ "\n");
     output_string out_chan (ecall_table ^ "\n");
     output_string out_chan (entry_table ^ "\n");
     output_string out_chan "\n";
@@ -1469,9 +1565,10 @@
     List.iter check_ecall priv_ecall_names
 
 (* Check that there is at least one public ECALL function. *)
-let check_priv_funcs (ec: enclave_content) =
+let check_priv_and_exception_funcs (ec: enclave_content) =
   let priv_bits = tf_list_to_priv_list ec.tfunc_decls in
-  if List.for_all (fun is_priv -> is_priv) priv_bits
+  let exception_bits = tf_list_to_exception_list ec.tfunc_decls in
+  if List.for_all2 (fun is_priv is_exception_handler -> is_priv || is_exception_handler) priv_bits exception_bits
   then failwithf "the enclave `%s' contains no public root ECALL.\n" ec.file_shortnm
   else report_orphaned_priv_ecall ec
 
@@ -1490,6 +1587,7 @@
         include_list = ec1.include_list @ ec2.include_list;
         import_exprs = [];
         comp_defs    = ec1.comp_defs   @ ec2.comp_defs;
+        errno_list   = ec1.errno_list  @ ec2.errno_list;
         tfunc_decls  = ec1.tfunc_decls @ ec2.tfunc_decls;
         ufunc_decls  = ec1.ufunc_decls @ ec2.ufunc_decls; }
   in
@@ -1553,6 +1651,6 @@
     create_dir ep.trusted_dir;
     check_duplication ec;
     check_allow_list ec;
-    (if not ep.header_only then check_priv_funcs ec);
+    (if not ep.header_only then check_priv_and_exception_funcs ec);
     (if ep.gen_untrusted then (gen_untrusted_header ec; if not ep.header_only then gen_untrusted_source ec));
     (if ep.gen_trusted then (gen_trusted_header ec; if not ep.header_only then gen_trusted_source ec))
diff -Nur -x '*.png' -x '*.gif' sdk/edger8r/linux/Lexer.mll sdk/edger8r/linux/Lexer.mll
--- sdk/edger8r/linux/Lexer.mll
+++ sdk/edger8r/linux/Lexer.mll
@@ -79,6 +79,8 @@
   | "struct"     { Tstruct }
   | "union"      { Tunion }
   | "enum"       { Tenum }
+  | "errno_list" { Terrno_list }
+  | "exception_handler" { Texception_handler }
 
   (* specifier *)
   | "enclave"    { Tenclave }
diff -Nur -x '*.png' -x '*.gif' sdk/edger8r/linux/Parser.mly sdk/edger8r/linux/Parser.mly
--- sdk/edger8r/linux/Parser.mly
+++ sdk/edger8r/linux/Parser.mly
@@ -261,7 +261,7 @@
 %token Tchar Tshort Tunsigned Tint Tfloat Tdouble
        Tint8 Tint16 Tint32 Tint64
        Tuint8 Tuint16 Tuint32 Tuint64
-       Tsizet Twchar Tvoid Tlong Tstruct Tunion Tenum
+       Tsizet Twchar Tvoid Tlong Tstruct Tunion Tenum Terrno_list Texception_handler
 %token Tenclave Tfrom Timport Ttrusted Tuntrusted Tallow Tpropagate_errno
 
 %start start_parsing
@@ -462,6 +462,19 @@
   | enum_definition                   { $1 }
   ;
 
+errno_list: Terrno_list TLBrace errno_list_body TRBrace {
+      { Ast.errnos = $3; }
+    }
+  ;
+
+errno_list_body: /* empty */ { [] }
+  | errno_list_eles          { List.rev $1 }
+  ;
+
+errno_list_eles: Tidentifier           { [$1] }
+  | errno_list_eles TComma Tidentifier { $3 :: $1 }
+  ;
+
 member_list: member_def TSemicolon    { [$1] }
   | member_list member_def TSemicolon { $2 :: $1 }
   ;
@@ -519,10 +532,15 @@
   | Tpublic                    { false  }
   ;
 
+/* is exception_handler? Default to false. */
+exception_handler: /* nothing */ { false }
+  | Texception_handler           { true }
+  ;
+
 trusted_functions: /* nothing */          { [] }
-  | trusted_functions access_modifier func_def TSemicolon {
-      check_ptr_attr $3 (symbol_start_pos(), symbol_end_pos());
-      Ast.Trusted { Ast.tf_fdecl = $3; Ast.tf_is_priv = $2 } :: $1
+  | trusted_functions exception_handler access_modifier func_def TSemicolon {
+      check_ptr_attr $4 (symbol_start_pos(), symbol_end_pos());
+      Ast.Trusted { Ast.tf_fdecl = $4; Ast.tf_is_priv = $3; Ast.tf_is_exception_handler = $2 } :: $1
     }
   ;
 
@@ -589,6 +607,7 @@
   | expressions include_declaration           { Ast.Include($2)   :: $1 }
   | expressions import_declaration TSemicolon { Ast.Importing($2) :: $1 }
   | expressions composite_defs TSemicolon     { Ast.Composite($2) :: $1 }
+  | expressions errno_list TSemicolon         { Ast.ErrnoList($2) :: $1 }
   | expressions enclave_functions             { Ast.Interface($2) :: $1 }
   ;
 
diff -Nur -x '*.png' -x '*.gif' sdk/edger8r/linux/Util.ml sdk/edger8r/linux/Util.ml
--- sdk/edger8r/linux/Util.ml
+++ sdk/edger8r/linux/Util.ml
@@ -68,12 +68,18 @@
 --untrusted           Generate untrusted proxy and bridge\n\
 --trusted             Generate trusted proxy and bridge\n\
 --untrusted-dir <dir> Specify the directory for saving untrusted code\n\
---trusted-dir   <dir> Specify the directory for saving trusted code\n\
+--trusted-dir   <dir> Specify the directory for saving trusted code\n\ 
+--version             Print the application version string\n\
 --help                Print this help message\n";
   eprintf "\n\
 If neither `--untrusted' nor `--trusted' is specified, generate both.\n";
   exit 1
 
+(* Print the version of this program. *)
+let version (progname: string) =
+  printf "version: %s 1.9.Google0\n" progname;
+  exit 0
+
 
 (* Command line parsing facilities. *)
 type edger8r_params = {
@@ -128,6 +134,7 @@
                 []    -> usage progname
               | x::xs -> t_dir := x; local_parser xs)
             | "--help" -> usage progname
+            | "--version" -> version progname
             | "--search-path" ->
                 if ops = [] then usage progname
                 else
diff -Nur -x '*.png' -x '*.gif' sdk/sign_tool/SignTool/Makefile sdk/sign_tool/SignTool/Makefile
--- sdk/sign_tool/SignTool/Makefile
+++ sdk/sign_tool/SignTool/Makefile
@@ -31,7 +31,10 @@
 
 include ../../../buildenv.mk
 
-CXXFLAGS += -Werror
+CXXFLAGS += -Werror \
+       -static \
+       -static-libgcc \
+       -static-libstdc++
 CFLAGS   += -Werror
 
 INC += $(ADDED_INC)
diff -Nur -x '*.png' -x '*.gif' sdk/simulation/assembly/linux/Makefile sdk/simulation/assembly/linux/Makefile
--- sdk/simulation/assembly/linux/Makefile
+++ sdk/simulation/assembly/linux/Makefile
@@ -31,7 +31,7 @@
 
 include ../../../../buildenv.mk
 
-ASFLAGS  += -Werror $(CFLAGS)
+ASFLAGS  += -Werror $(CFLAGS) -Wa,--noexecstack
 CPPFLAGS += -Werror -I$(COMMON_DIR)/inc/internal
 
 .PHONY: all
diff -Nur -x '*.png' -x '*.gif' sdk/simulation/trtssim/linux/Makefile sdk/simulation/trtssim/linux/Makefile
--- sdk/simulation/trtssim/linux/Makefile
+++ sdk/simulation/trtssim/linux/Makefile
@@ -34,7 +34,8 @@
 CPPFLAGS += -I$(COMMON_DIR)/inc/         \
             -I$(COMMON_DIR)/inc/tlibc/   \
             -I$(COMMON_DIR)/inc/internal \
-            -I$(LINUX_SDK_DIR)/trts/
+            -I$(LINUX_SDK_DIR)/trts/ \
+	    -I$(RUN_TIME_SUPPORT_DIR)/ 
 
 CFLAGS   += $(ENCLAVE_CFLAGS)
 ASFLAGS  := -DSE_SIM -Werror $(CFLAGS)
diff -Nur -x '*.png' -x '*.gif' sdk/simulation/uae_service_sim/linux/Makefile sdk/simulation/uae_service_sim/linux/Makefile
--- sdk/simulation/uae_service_sim/linux/Makefile
+++ sdk/simulation/uae_service_sim/linux/Makefile
@@ -102,6 +102,9 @@
 	$(OBJCOPY) --add-gnu-debuglink=$(DLLNAME_DEBUG) $(DLLNAME)
 endif
 
+libsgx_uae_service_sim.a: $(OBJ) -lrdrand -lcrypto_px
+	$(AR) rcsD $@ $(OBJ)
+
 %.o: %.c
 	$(CC) $(CFLAGS) -Werror -fPIC -c $< -o $@
 
diff -Nur -x '*.png' -x '*.gif' sdk/simulation/urtssim/get_state.cpp sdk/simulation/urtssim/get_state.cpp
--- sdk/simulation/urtssim/get_state.cpp
+++ sdk/simulation/urtssim/get_state.cpp
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2011-2017 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+#include "td_mngr.h"
+
+extern "C" int is_tcs_sim_active(const tcs_t *tcs)
+{
+  if (tcs)
+  {
+    tcs_sim_t* tcs_sim = (tcs_sim_t*)(tcs->reserved);
+    if (tcs_sim)
+      return (tcs_sim->tcs_state == TCS_STATE_ACTIVE ? 1 : 0);
+  }
+  return 0;
+}
diff -Nur -x '*.png' -x '*.gif' sdk/simulation/urtssim/linux/Makefile sdk/simulation/urtssim/linux/Makefile
--- sdk/simulation/urtssim/linux/Makefile
+++ sdk/simulation/urtssim/linux/Makefile
@@ -52,6 +52,7 @@
 
 CPPFLAGS += -I$(COMMON_DIR)/inc/internal      \
             -I$(LINUX_PSW_DIR)/urts/linux     \
+            -I$(SIM_DIR)/assembly/linux       \
             -I$(SIM_DIR)/tinst                \
             -I$(SIM_DIR)/uinst
 
@@ -97,7 +98,8 @@
         $(SIM_DIR)/uinst/u_instructions.o  \
         $(SIM_DIR)/uinst/enclave_mngr.o    \
         $(SIM_DIR)/uinst/linux/set_tls.o   \
-        $(SIM_DIR)/uinst/linux/restore_tls.o
+        $(SIM_DIR)/uinst/linux/restore_tls.o \
+        $(SIM_DIR)/urtssim/get_state.o
 
 CPP_OBJ := $(OBJ1) $(OBJ2) $(OBJ3) $(OBJ5)
 OBJ     := $(CPP_OBJ) $(OBJ4)
@@ -133,6 +135,9 @@
 	$(CXX) $(CXXFLAGS) -shared -Wl,-soname=$(SONAME) $(OBJ) $(OBJ6) $(LDFLAGS) $(LDLIBS) -o $@
 endif
 
+libsgx_urts_sim.a: simasm uinst driver_api wrapper uae_service_sim $(OBJ) $(OBJ6) -lcrypto_px ittnotify
+	$(AR) rcsD $@ $(OBJ) $(OBJ6) $(simasm) $(uinst) $(driver_api) $(wrapper) $(uae_service_sim) $(ittnotify)
+
 $(LIBURTSSIM_DEBUG): $(LIBURTSSIM_SHARED)
 ifndef DEBUG
 	$(CP) $(LIBURTSSIM_SHARED) $(LIBURTSSIM_SHARED).orig
diff -Nur -x '*.png' -x '*.gif' sdk/tlibc/string/memset_s.c sdk/tlibc/string/memset_s.c
--- sdk/tlibc/string/memset_s.c
+++ sdk/tlibc/string/memset_s.c
@@ -37,6 +37,7 @@
 #include <errno.h>
 #include <stdint.h>
 #include <string.h>
+#include "rts_config.h"
 
 /*
  * __memset_vp is a volatile pointer to a function.
diff -Nur -x '*.png' -x '*.gif' sdk/tlibcrypto/sgx_aes_ctr.cpp sdk/tlibcrypto/sgx_aes_ctr.cpp
--- sdk/tlibcrypto/sgx_aes_ctr.cpp
+++ sdk/tlibcrypto/sgx_aes_ctr.cpp
@@ -34,6 +34,7 @@
 #include "ippcp.h"
 #include "stdlib.h"
 #include "string.h"
+#include "rts_config.h"
 
 /* AES-CTR 128-bit
  * Parameters:
diff -Nur -x '*.png' -x '*.gif' sdk/tlibcrypto/sgx_aes_gcm.cpp sdk/tlibcrypto/sgx_aes_gcm.cpp
--- sdk/tlibcrypto/sgx_aes_gcm.cpp
+++ sdk/tlibcrypto/sgx_aes_gcm.cpp
@@ -34,6 +34,7 @@
 #include "ippcp.h"
 #include "stdlib.h"
 #include "string.h"
+#include "rts_config.h"
 
 /* Rijndael AES-GCM
 * Parameters:
diff -Nur -x '*.png' -x '*.gif' sdk/tlibcrypto/sgx_cmac128.cpp sdk/tlibcrypto/sgx_cmac128.cpp
--- sdk/tlibcrypto/sgx_cmac128.cpp
+++ sdk/tlibcrypto/sgx_cmac128.cpp
@@ -34,6 +34,7 @@
 #include "ippcp.h"
 #include "stdlib.h"
 #include "string.h"
+#include "rts_config.h"
 
 
 /* Message Authentication - Rijndael 128 CMAC
diff -Nur -x '*.png' -x '*.gif' sdk/tlibcrypto/sgx_ecc256_common.h sdk/tlibcrypto/sgx_ecc256_common.h
--- sdk/tlibcrypto/sgx_ecc256_common.h
+++ sdk/tlibcrypto/sgx_ecc256_common.h
@@ -39,6 +39,7 @@
 #include "util.h"
 #include "stdlib.h"
 #include "string.h"
+#include "rts_config.h"
 
 #ifndef ERROR_BREAK
 #define ERROR_BREAK(x)  if(x != ippStsNoErr){break;}
diff -Nur -x '*.png' -x '*.gif' sdk/trts/init_enclave.cpp sdk/trts/init_enclave.cpp
--- sdk/trts/init_enclave.cpp
+++ sdk/trts/init_enclave.cpp
@@ -83,6 +83,9 @@
     {
         return -1;
     }
+    // Moved from do_init_enclave because clearing the heap was causing libc
+    // to lose state.
+    memset(GET_PTR(void, enclave_base, g_global_data.heap_offset), 0, g_global_data.heap_size);
 
     // Check if the ms is outside the enclave.
     // sgx_is_outside_enclave() should be placed after relocate_enclave()
@@ -130,7 +133,6 @@
     {
         return SGX_ERROR_UNEXPECTED;
     }
-    memset(GET_PTR(void, enclave_base, g_global_data.heap_offset), 0, g_global_data.heap_size);
     g_enclave_state = ENCLAVE_INIT_DONE;
     return SGX_SUCCESS;
 }
diff -Nur -x '*.png' -x '*.gif' sdk/trts/linux/trts_pic.h sdk/trts/linux/trts_pic.h
--- sdk/trts/linux/trts_pic.h
+++ sdk/trts/linux/trts_pic.h
@@ -55,7 +55,7 @@
 #define SGX_ERROR_ENCLAVE_CRASHED     0x000001006 // enclave is crashed
 #define SGX_ERROR_STACK_OVERRUN       0x000001009 // enclave is running out of stack
 
-#define STATIC_STACK_SIZE   (SE_WORDSIZE * 100)
+#define STATIC_STACK_SIZE   (SE_WORDSIZE * 1024)
 
 /* Thread Data
  * c.f. data structure defintion for thread_data_t in `rts.h'.
diff -Nur -x '*.png' -x '*.gif' sdk/trts/linux/trts_pic.S sdk/trts/linux/trts_pic.S
--- sdk/trts/linux/trts_pic.S
+++ sdk/trts/linux/trts_pic.S
@@ -476,7 +476,11 @@
     mov     SE_WORDSIZE*1(%xcx), %xax
     push    %xax                       # push xcx
     mov     SE_WORDSIZE*4(%xcx), %xax
+#ifdef LINUX32
     sub     $(SE_WORDSIZE), %xax       # xax: xsp
+#else
+    sub     $(SE_WORDSIZE*17), %xax    # xax: xsp. SE_WORDSIZE*17: 128-bytes red zone + space to save xip
+#endif
 
 # restore registers except xax, xcx, xsp
     mov     SE_WORDSIZE*2(%xcx), %xdx
@@ -512,4 +516,8 @@
     pop     %xcx                       # restore xcx
     pop     %xsp                       # xsp: xax
     xchg    %xax, %xsp
+#ifdef LINUX32
     ret
+#else
+    ret     $(SE_WORDSIZE*16)         # restore xip and xsp
+#endif
diff -Nur -x '*.png' -x '*.gif' sdk/trts/linux/x86_64/setcontext.S sdk/trts/linux/x86_64/setcontext.S
--- sdk/trts/linux/x86_64/setcontext.S
+++ sdk/trts/linux/x86_64/setcontext.S
@@ -24,12 +24,17 @@
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
+#define __NR_rt_sigprocmask 0
+#ifndef __linux__
+#define __linux__
+#endif
+
 #include "ucontext_i.h"
 #if (!ISE)
 #if defined __linux__
-#include <asm/unistd.h>
+//#include <asm/unistd.h>
 #define	SIG_SETMASK   2
-#define	SIGSET_BYTE_SIZE   (64/8)
+#define	SIGSET_BYTE_SIZE   8
 #elif defined __FreeBSD__
 #include <sys/syscall.h>
 #endif
diff -Nur -x '*.png' -x '*.gif' sdk/trts/trts.cpp sdk/trts/trts.cpp
--- sdk/trts/trts.cpp
+++ sdk/trts/trts.cpp
@@ -39,6 +39,7 @@
 #include "global_data.h"
 
 #include "internal/rts.h"
+#include "rts_config.h"
 
 #ifdef SE_SIM
 #include "t_instructions.h"    /* for `g_global_data_sim' */
@@ -288,6 +289,11 @@
 }
 
 #include "trts_internal.h"
+
+int sgx_is_enclave_crashed(void) {
+  return get_enclave_state() == ENCLAVE_CRASHED;
+}
+
 extern "C" int enter_enclave(int index, void *ms, void *tcs, int cssa)
 {
     if(get_enclave_state() == ENCLAVE_CRASHED)
@@ -296,7 +302,16 @@
     }
 
     sgx_status_t error = SGX_ERROR_UNEXPECTED;
-    if(cssa == 0)
+    // Check whether the incoming ecall is a user exception. If index is within
+    // range of the ecall table size, the is_exception field will be true for
+    // user exceptions.
+    uint8_t is_user_exception =
+        (index >= 0 && index < int(g_ecall_table.nr_ecall)) &&
+        g_ecall_table.ecall_table[index].is_exception;
+    // For a user exception, call |do_ecall| to enter enclave and handle the
+    // signal, in this case cssa could be 0 or 1 (which is likely to be 1 when
+    // an enclave is interrupted by an exception).
+    if(cssa == 0 || (is_user_exception && cssa == 1))
     {
         if(index >= 0)
         {
diff -Nur -x '*.png' -x '*.gif' sdk/trts/trts_ecall.cpp sdk/trts/trts_ecall.cpp
--- sdk/trts/trts_ecall.cpp
+++ sdk/trts/trts_ecall.cpp
@@ -57,6 +57,11 @@
             return SGX_ERROR_ECALL_NOT_ALLOWED;
         return SGX_SUCCESS;
     }
+    // Exception handlers should be allowed no matter what ocall status it is.
+    if (g_ecall_table.ecall_table[ordinal].is_exception)
+    {
+      return SGX_SUCCESS;
+    }
     ocall_context_t *context = reinterpret_cast<ocall_context_t*>(thread_data->last_sp);
     if(context->ocall_flag != OCALL_FLAG)
     {
diff -Nur -x '*.png' -x '*.gif' sdk/trts/trts_internal.h sdk/trts/trts_internal.h
--- sdk/trts/trts_internal.h
+++ sdk/trts/trts_internal.h
@@ -34,9 +34,9 @@
 #include "util.h"
 
 #ifdef SE_64
-#define STATIC_STACK_SIZE 8*100
+#define STATIC_STACK_SIZE (8 * 1024)
 #else
-#define STATIC_STACK_SIZE 4*100
+#define STATIC_STACK_SIZE (4 * 1024)
 #endif
 
 #define TD2TCS(td) ((const void *)(((thread_data_t*)(td))->stack_base_addr + (size_t)STATIC_STACK_SIZE + (size_t)SE_GUARD_PAGE_SIZE))
@@ -44,6 +44,7 @@
 typedef struct {
     const void     *ecall_addr;
     uint8_t         is_priv;
+    uint8_t         is_exception;
 } ecall_addr_t;
 
 typedef struct {
diff -Nur -x '*.png' -x '*.gif' sdk/trts/trts_ocall.cpp sdk/trts/trts_ocall.cpp
--- sdk/trts/trts_ocall.cpp
+++ sdk/trts/trts_ocall.cpp
@@ -38,6 +38,7 @@
 #include "util.h"
 #include "xsave.h"
 #include "trts_internal.h"
+#include "rts_config.h"
 
 extern "C" sgx_status_t asm_oret(uintptr_t sp, void *ms);
 extern "C" sgx_status_t __morestack(const unsigned int index, void *ms);
--- external/tinyxml2/tinyxml2.cpp
+++ external/tinyxml2/tinyxml2.cpp
@@ -409,14 +409,17 @@
             --output;
             *output = (char)((input | BYTE_MARK) & BYTE_MASK);
             input >>= 6;
+            /* fallthrough */
         case 3:
             --output;
             *output = (char)((input | BYTE_MARK) & BYTE_MASK);
             input >>= 6;
+            /* fallthrough */
         case 2:
             --output;
             *output = (char)((input | BYTE_MARK) & BYTE_MASK);
             input >>= 6;
+            /* fallthrough */
         case 1:
             --output;
             *output = (char)(input | FIRST_BYTE_MARK[*length]);
--- /dev/null
+++ BUILD
@@ -0,0 +1,509 @@
+# linux-sgx is the Intel SGX SDK
+
+package(default_visibility = ["//visibility:public"])
+
+licenses(["notice"])  # BSD
+
+exports_files([
+    "LICENSE",
+    "enclave_sim.lds",
+    "enclave_test_private.pem",
+])
+
+load(
+    ":sgx_sdk.bzl",
+    "sgx_sdk_library",
+    "sgx_enclave",
+    "sgx_enclave_configuration",
+)
+
+config_setting(
+    name = "dbg",
+    values = {
+        "compilation_mode": "dbg",
+    },
+)
+
+sgx_enclave_configuration(name = "enclave_debug_config")
+
+
+# genrule is needed to compile third_party protobufs.
+genrule(
+    name = "ipc_common_proto",
+    srcs = ["psw/ae/common/proto/messages.proto"],
+    outs = [
+        "psw/ae/common/proto/messages.pb.h",
+        "psw/ae/common/proto/messages.pb.cc",
+    ],
+    cmd = ("$(location @com_google_protobuf//:protoc) " +
+           "--cpp_out=$(GENDIR) $(SRCS)"),
+    tools = ["@com_google_protobuf//:protoc"],
+)
+
+cc_library(
+    name = "uae_service",
+    srcs = glob([
+        "psw/uae_service/*.h",
+        "psw/ae/common/inc/*.h",
+        "psw/uae_service/uae_wrapper/inc/*.h",
+        "psw/uae_service/uae_wrapper/src/*.cpp",
+        "psw/uae_service/*.cpp",
+        "psw/ae/common/src/*.cpp",
+        "common/inc/*.h",
+        "common/inc/internal/se_*.h",
+    ]) + [
+        "external/epid/epid/common/types.h",
+        ":ipc_common_proto",
+    ],
+    hdrs = [
+        "common/inc/internal/arch.h",
+        "common/inc/internal/oal/uae_oal_api.h",
+        "common/inc/internal/uae_service_internal.h",
+        "psw/ae/aesm_service/source/upse/platform_info_blob.h",
+        "psw/ae/inc/aeerror.h",
+        "psw/ae/inc/internal/aesm_error.h",
+        "psw/ae/inc/internal/epid_pve_type.h",
+        "psw/ae/inc/se_sig_rl.h",
+    ],
+    copts = [
+        "-fPIC",
+        "-Iexternal/linux_sgx/psw/uae_service",
+        "-Iexternal/linux_sgx/psw/uae_service/uae_wrapper/inc",
+        "-Iexternal/linux_sgx/common/inc",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/external/epid/",
+        "-Iexternal/linux_sgx/psw/ae/inc/internal",
+        "-Iexternal/linux_sgx/psw/ae/inc",
+        "-Iexternal/linux_sgx/psw/ae/aesm_service/source",
+        "-Iexternal/linux_sgx/psw/ae/common/inc",
+        "-Iexternal/linux_sgx/psw/ae/common/proto",
+    ],
+    textual_hdrs = ["common/inc/internal/inst.h"],
+    deps = [
+        "@com_google_protobuf//:protobuf",
+    ],
+)
+
+filegroup(
+    name = "build_tools",
+    srcs = glob(["tools/**"]),
+)
+
+cc_library(
+    name = "se_wrapper",
+    srcs = [
+        "common/src/se_event.c",
+        "common/src/se_map.c",
+        "common/src/se_memory.c",
+        "common/src/se_rwlock.c",
+        "common/src/se_thread.c",
+        "common/src/se_time.c",
+        "common/src/se_trace.c",
+    ],
+    copts = [
+        "-fPIC",
+        "-Iexternal/linux_sgx/common/inc",
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    textual_hdrs = glob([
+        "common/inc/*.h",
+        "common/inc/internal/*.h",
+    ]),
+)
+
+cc_library(
+    name = "urts_hw_inc",
+    srcs = [
+        "psw/urts/cpu_features.cpp",
+        "psw/urts/enclave.cpp",
+        "psw/urts/enclave_creator_hw_com.cpp",
+        "psw/urts/enclave_mutex.cpp",
+        "psw/urts/launch_checker.cpp",
+        "psw/urts/linux/debugger_support.cpp",
+        "psw/urts/linux/enclave_creator_hw.cpp",
+        "psw/urts/linux/enter_enclave.S",
+        "psw/urts/linux/get_thread_id.cpp",
+        "psw/urts/linux/misc.cpp",
+        "psw/urts/linux/sig_handler.cpp",
+        "psw/urts/linux/urts.cpp",
+        "psw/urts/loader.cpp",
+        "psw/urts/node.cpp",
+        "psw/urts/parser/elfparser.cpp",
+        "psw/urts/parser/section.cpp",
+        "psw/urts/prd_css_util.cpp",
+        "psw/urts/routine.cpp",
+        "psw/urts/se_detect.cpp",
+        "psw/urts/se_ocalls.cpp",
+        "psw/urts/tcs.cpp",
+        "psw/urts/urts_version.cpp",
+        "psw/urts/urts_xsave.cpp",
+    ],
+    copts = [
+        "-fPIC",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/linux_sgx/common/inc",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/linux_sgx/external/vtune/linux/include",
+        "-Iexternal/linux_sgx/external/vtune/linux/sdk/src/ittnotify",
+    ],
+    linkopts = [
+        "-Wl,--no-as-needed -ldl",
+    ],
+    textual_hdrs = glob([
+        "common/inc/**/*.h",
+        "psw/urts/**/*.h",
+    ]) + [
+        "common/inc/internal/se_lock.hpp",
+        "psw/urts/parser/update_global_data.hxx",
+        "external/vtune/linux/include/ittnotify.h",
+        "external/vtune/linux/sdk/src/ittnotify/ittnotify_config.h",
+        "external/vtune/linux/sdk/src/ittnotify/ittnotify_types.h",
+    ],
+    deps = [
+        ":ittnotify_lib",
+        ":se_wrapper",
+        ":uae_service",
+        "@com_google_protobuf//:protobuf",
+    ],
+)
+
+cc_library(
+    name = "ittnotify_lib",
+    srcs = [":ittnotify"],
+    linkstatic = 1,
+    alwayslink = 1,
+)
+
+sgx_sdk_library(
+    name = "ittnotify",
+    path = "external/vtune/linux/sdk/src/ittnotify/",
+)
+
+sgx_sdk_library(
+    name = "trts_sim",
+    path = "sdk/simulation/trtssim/linux/",
+)
+
+sgx_sdk_library(
+    name = "sgx_sign_tool",
+    bin = "sgx_sign",
+    path = "sdk/sign_tool/SignTool/",
+)
+
+cc_library(
+    name = "trts_inc",
+    srcs = [
+        ":trts_sim",
+    ],
+    linkstatic = 1,
+    alwayslink = 1,
+)
+
+sgx_sdk_library(
+    name = "urts_sim",
+    path = "sdk/simulation/urtssim/linux/",
+)
+
+sgx_sdk_library(
+    name = "uae_service_sim",
+    path = "sdk/simulation/uae_service_sim/linux/",
+)
+
+cc_library(
+    name = "urts_inc",
+    # do not sort.
+    srcs = [
+        ":urts_sim",
+        ":uae_service_sim",
+    ],
+    linkopts = [
+        "-Wl,--no-as-needed -ldl",
+    ],
+    linkstatic = 1,
+    deps = [
+        ":crypto_px_xp",
+        ":ittnotify_lib",
+        ":se_wrapper",
+    ],
+)
+
+# The following targets are designed with '.blazerc' and '--config=sgx'.
+cc_library(
+    name = "common_inc",
+    hdrs = glob([
+        "common/inc/**/*.h",
+    ]),
+)
+
+cc_library(
+    name = "common_inc_internal",
+    hdrs = glob([
+        "common/inc/internal/**/*.h",
+    ]),
+    copts = [
+        "-fpie",
+        "-Iexternal/linux_sgx/common/inc",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/external/epid/inc",
+    ],
+    deps = [
+        ":common_inc",
+    ],
+)
+
+cc_library(
+    name = "trts_hw_inc",
+    srcs = glob([
+        "sdk/trts/linux/*.cpp",
+        "sdk/trts/linux/*.c",
+        "sdk/trts/linux/*.S",
+        "sdk/trts/linux/x86_64/*.S",
+        "sdk/trts/linux/**/*.h",
+        "sdk/trts/*.cpp",
+        "sdk/trts/*.c",
+        "sdk/trts/*.S",
+        "sdk/trts/*.h",
+    ]) + [
+        "sdk/cpprt/linux/libunwind/src/x86_64/ucontext_i.h",
+    ],
+    hdrs = [
+        "sdk/trts/trts_util.h",
+    ],
+    copts = [
+        "-fpie",
+        "-Iexternal/linux_sgx/sdk/cpprt/linux/libunwind/src/x86_64",
+        "-Iexternal/linux_sgx/common/inc",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/trts",
+        "-Iexternal/linux_sgx/runtime_support",
+    ],
+    linkstatic = 1,
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":sgx_runtime_support",
+    ],
+    alwayslink = 1,
+)
+
+cc_library(
+    name = "ippbase",
+    hdrs = [
+        "external/crypto_px/include/ippbase.h",
+    ],
+    copts = [
+        "-fpie",
+    ],
+)
+
+cc_library(
+    name = "crypto_px",
+    srcs = glob([
+        "external/crypto_px/sources/ippcp/src/*.c",
+        "external/crypto_px/sources/ippcp/src/*.h",
+        "external/crypto_px/sources/include/*.h",
+    ]),
+    hdrs = glob(["external/crypto_px/include/*.h"]),
+    copts = [
+        "-fpie",
+        "-Iexternal/linux_sgx/external/crypto_px/sources/ippcp/srcs",
+        "-Iexternal/linux_sgx/external/crypto_px/sources/include",
+        "-Iexternal/linux_sgx/external/crypto_px/include",
+        "-D_PX",
+        "-D_ARCH_EM64T",
+        "-Werror",
+        "-Wno-unknown-pragmas",
+        "-Wno-unused-but-set-variable",
+        "-Wno-strict-aliasing",
+    ],
+    textual_hdrs = [
+        "external/crypto_px/sources/include/ippver.gen",
+        "external/crypto_px/sources/include/ippverstr.gen",
+    ],
+    deps = [
+        ":ippbase",
+    ],
+)
+
+cc_library(
+    name = "crypto_px_xp",
+    srcs = glob([
+        "external/crypto_px/sources/ippcp/src/*.c",
+    ]),
+    copts = [
+        "-fpie",
+        "-Iexternal/linux_sgx/external/crypto_px/sources/ippcp/srcs",
+        "-Iexternal/linux_sgx/external/crypto_px/sources/include",
+        "-Iexternal/linux_sgx/external/crypto_px/include",
+        "-D_PX",
+        "-D_ARCH_EM64T",
+        "-Werror",
+        "-Wno-unknown-pragmas",
+        "-Wno-unused-but-set-variable",
+        "-Wno-strict-aliasing",
+    ],
+    linkstatic = 1,
+    textual_hdrs = glob([
+        "external/crypto_px/sources/include/*.h",
+        "external/crypto_px/sources/ippcp/src/*.h",
+        "external/crypto_px/include/*.h",
+    ]) + [
+        "external/crypto_px/sources/include/ippver.gen",
+        "external/crypto_px/sources/include/ippverstr.gen",
+    ],
+    deps = [
+        ":ippbase",
+    ],
+)
+
+cc_library(
+    name = "sgx_tthread",
+    srcs = glob([
+        "sdk/tlibthread/*.cpp",
+        "sdk/tlibthread/*.h",
+    ]) + [
+        "sdk/trts/trts_internal.h",
+    ],
+    copts = [
+        "-g -O0",
+        "-fpie",
+        "-Iexternal/linux_sgx/common/inc",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/external/crypto_px/include",
+        "-Iexternal/linux_sgx/sdk/tlibcrypto/",
+        "-Iexternal/linux_sgx/sdk/trts/",
+        "-Iexternal/linux_sgx/runtime_support/",
+    ],
+    linkstatic = 1,
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":sgx_runtime_support",
+    ],
+)
+
+cc_library(
+    name = "sgx_tcrypto",
+    srcs = glob([
+        "sdk/tlibcrypto/*.cpp",
+        "sdk/tlibcrypto/*.h",
+    ]),
+    copts = [
+        "-g -O0",
+        "-fpie",
+        "-Iexternal/linux_sgx/common/inc",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/external/crypto_px/include",
+        "-Iexternal/linux_sgx/sdk/tlibcrypto/",
+        "-Iexternal/linux_sgx/runtime_support/",
+    ],
+    linkstatic = 1,
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":crypto_px",
+        ":sgx_runtime_support",
+    ],
+)
+
+cc_library(
+    name = "sgx_runtime_support",
+    srcs = [
+        "sdk/compiler-rt/stack_chk.c",
+        "sdk/trts/trts_util.h",
+        "sdk/tlibc/gen/se_cpuid.c",
+        "sdk/tlibc/string/consttime_memequal.c",
+        "sdk/tlibc/string/memset_s.c",
+    ] + glob(["runtime_support/**/*.c"]),
+    hdrs = glob(["runtime_support/**/*.h"]),
+    copts = [
+        "-Iexternal/linux_sgx/common/inc",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/trts/",
+        "-Iexternal/linux_sgx/runtime_support",
+    ],
+    linkopts = [
+        "-Wl,--export-dynamic",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+    ],
+)
+
+# A wrapping library that wraps linux_sgx targets used by enclave.
+cc_library(
+    name = "intel_runtime",
+    deps = [
+        ":common_inc",
+        ":crypto_px",
+        ":sgx_spin_lock",
+        ":sgx_tcrypto",
+        ":sgx_tthread",
+        ":trts_inc",
+    ],
+)
+
+
+cc_library(
+    name = "sgx_spin_lock",
+    srcs = [
+        "sdk/tlibc/gen/spinlock.c",
+    ],
+    hdrs = [
+        "common/inc/sgx_spinlock.h",
+    ],
+    copts = [
+        "-fpie",
+        "-Iexternal/linux_sgx/common/inc",
+    ],
+    deps = [
+        ":common_inc",
+    ],
+)
+
+
+
+
+# The edger8r tool uses an language unsupported by Bazel, so call ocamlbuild
+# in a genrule. (sudo apt-get install ocaml)
+filegroup(
+    name = "edger8r_srcs",
+    srcs = [
+        "sdk/edger8r/linux/Ast.ml",
+        "sdk/edger8r/linux/CodeGen.ml",
+        "sdk/edger8r/linux/Edger8r.ml",
+        "sdk/edger8r/linux/Lexer.mll",
+        "sdk/edger8r/linux/Parser.mly",
+        "sdk/edger8r/linux/Preprocessor.ml",
+        "sdk/edger8r/linux/SimpleStack.ml",
+        "sdk/edger8r/linux/Util.ml",
+    ],
+)
+
+genrule(
+    name = "sgx_edger8r",
+    srcs = [":edger8r_srcs"],
+    outs = ["sgx_edger8r_binary"],
+    cmd = "OUT=`pwd`/$(@); " +
+          "BUILD=`mktemp -d`; " +
+          "LOCS=($(locations :edger8r_srcs)); " +
+          "cd $$(dirname \"$${LOCS[0]}\"); " +
+          # Call ocamlbuild directly instead of make since the default
+          # build directory can get permission denied on mkdir.
+          "ocamlbuild -libs str,unix -build-dir $$BUILD Edger8r.native > /dev/null; " +
+          "cp $$BUILD/Edger8r.native $$OUT",
+    executable = True,
+    output_to_bindir = True,
+)
+
+
+config_setting(
+    name = "sgx_sim",
+    values = {
+        "define": "SGX_SIM=1",
+    },
+)
--- /dev/null
+++ enclave_sim.lds
@@ -0,0 +1,9 @@
+enclave.so
+{
+    global:
+        enclave_entry;
+        g_global_data;
+        g_global_data_sim;
+    local:
+        *;
+};
--- /dev/null
+++ sgx_sdk.bzl
@@ -0,0 +1,251 @@
+"""Build tools for supporting Intel's SDK."""
+
+load("@com_google_asylo_backend_provider//:enclave_info.bzl", "enclave_info")
+
+# USE_OPT_LIBS=1 does not work in our build.
+SGX_STATIC_MAKE_FLAGS = "USE_OPT_LIBS=0 ARCH=x86_64"
+sgx_enclave_info = provider()
+sgx_enclave_config = provider()
+
+def _sgx_make_command(debug, path, libname, output, quiet):
+  """Returns the command string for calling make with the appropriate arguments.
+
+  Args:
+    debug: boolean, determines if the build is for debugging.
+    path: Path into Intel SGX SDK that contains a Makefile.
+    libname: The name of the target to make in 'path'/Makefile.
+    output: Path for the output built library.
+    quiet: boolean, determines whether to suppress non-error output.
+
+  Returns:
+    string: A bash script to call make with the appropriate configuration.
+  """
+  flags = ("DEBUG=1 SGX_DEBUG=1 " if debug else "") + SGX_STATIC_MAKE_FLAGS
+  make_path = "external/linux_sgx/" + path
+  redirect = ">/dev/null" if quiet else ""
+
+  command = "make -C {path} {lib} {flags} {redir}; cp {path}{lib} {out}".format(
+      path = make_path,
+      lib = libname,
+      flags = flags,
+      out = output,
+      redir = redirect)
+
+  return command
+
+def sgx_sdk_library(name, path, srcs=[], bin="", quiet=True):
+  """Build rule for running a makefile on the Intel SGX SDK.
+
+  Args:
+    name: Name for build target.
+    path: Path into Intel SGX SDK.
+    srcs: Srcs additional to Intel SGX SDK.
+    bin: Defaults to "", if set will be the resulting binary.
+    quiet: boolean, determines whether to suppress non-error output.
+
+  Returns:
+    Void.
+  """
+  libname = ""
+  if path.find("sdk") == 0:
+    libname = "libsgx_" + name + ".a"
+  else:
+    libname = "lib" + name + ".a"
+  executable = 0
+  if bin != "":
+    libname = bin
+    executable = 1
+  native.genrule(
+      name = name,
+      srcs = srcs + native.glob([
+          "common/**/*",
+          "external/**/*",
+          "linux/**/*",
+          "psw/**/*",
+          "sdk/**/*",
+          "buildenv.mk",
+          "Makefile",
+      ]) + [
+          "runtime_support/rts_config.h",
+      ],
+      outs = [libname],
+      cmd = select({
+         "@linux_sgx//:dbg": _sgx_make_command(debug=True, path=path, libname=libname, output="$(@)", quiet=quiet),
+         "//conditions:default": _sgx_make_command(debug=False, path=path, libname=libname, output="$(@)", quiet=quiet),
+      }),
+      executable = executable,
+      output_to_bindir = executable,
+      visibility = ["//visibility:public"],
+      tools = [
+          ":build_tools",
+          "@bazel_tools//tools/cpp:toolchain",
+          ],
+  )
+  return name
+
+
+def _sgx_unsigned_enclave(name,
+                          **kwargs):
+  """Build rule for creating an unsigned SGX enclave shared object file.
+
+  Args:
+    name: The enclave target name.
+    **kwargs: cc_binary arguments.
+  """
+
+# Append enclave specific arguments.
+  kwargs["copts"] = kwargs.get("copts", []) + [
+      "-Iexternal/linux_sgx/common/inc/",
+      "-fstack-protector",
+  ]
+  lds_label = "@linux_sgx//:enclave_sim.lds"
+  kwargs["linkopts"] = kwargs.get("linkopts", []) + [
+      "-static",
+      "-Wl,-Bstatic",
+      "-Wl,-Bsymbolic",
+      "-Wl,-pie,-eenclave_entry",
+      "-Wl,--defsym,__ImageBase=0",
+      "-Wl,--export-dynamic",
+      "-Wl,--version-script",
+      "$(location %s)" % lds_label,
+  ]
+  kwargs["linkshared"] = 1
+  kwargs["deps"] = kwargs.get("deps", []) + [
+      lds_label,
+      "@linux_sgx//:intel_runtime",
+  ]
+
+  # Create rule to build unsigned enclave.
+  native.cc_binary(
+      name = name,
+      visibility = None,
+      **kwargs
+  )
+
+def _sgx_enclave_configuration(ctx):
+  """Implementation of enclave signing configuration file formatting."""
+  xml_file = ctx.actions.declare_file(ctx.label.name + ".xml")
+  ctx.file_action(
+      output = xml_file,
+      content ="\n".join([
+          "<EnclaveConfiguration>",
+          "  <ProdID>%s</ProdID>" % ctx.attr.prodid,
+          "  <ISVSVN>%s</ISVSVN>" % ctx.attr.isvsvn,
+          "  <StackMaxSize>%s</StackMaxSize>" % ctx.attr.stack_max_size,
+          "  <HeapMaxSize>%s</HeapMaxSize>" % ctx.attr.heap_max_size,
+          "  <TCSNum>%s</TCSNum>" % ctx.attr.tcs_num,
+          "  <TCSPolicy>%s</TCSPolicy>" % ctx.attr.tcs_policy,
+          "  <DisableDebug>%s</DisableDebug>" % ctx.attr.disable_debug,
+          "  <MiscSelect>%s</MiscSelect>" % ctx.attr.misc_select,
+          "  <MiscMask>%s</MiscMask>" % ctx.attr.misc_mask,
+          "</EnclaveConfiguration>\n\n"]),
+  )
+  return [DefaultInfo(files=depset([xml_file])), sgx_enclave_config()]
+
+sgx_enclave_configuration = rule(
+    implementation=_sgx_enclave_configuration,
+    output_to_genfiles = True,
+    attrs={"prodid": attr.string(default="0"),
+           "isvsvn": attr.string(default="0"),
+           "stack_max_size": attr.string(default="0x40000"),
+           "heap_max_size": attr.string(default="0x100000"),
+           "tcs_num": attr.string(default="10"),
+           "tcs_policy": attr.string(default="1"),
+           # "1" for release enclaves.
+           "disable_debug": attr.string(default="0"),
+           "misc_select": attr.string(default="0"),
+           "misc_mask": attr.string(default="0xffffffff"),
+          })
+
+def _sgx_debug_sign_enclave_impl(ctx):
+  """Implementation of an automated signing process of an unsigned enclave."""
+  ctx.actions.run_shell(
+      inputs = [ctx.executable._sign_tool, ctx.file.unsigned, ctx.file._key,
+                ctx.file.config],
+      outputs = [ctx.outputs.executable],
+      progress_message = "Signing for debug: //{pkg}:{name}".format(
+          pkg = ctx.attr.unsigned.label.package,
+          name = ctx.attr.unsigned.label.name),
+      # Suppresses tool output on success.
+      command = "output=`%s $@ 2>&1` || echo $output" %
+          ctx.executable._sign_tool.path,
+      arguments = [
+          "sign",
+          "-enclave", ctx.file.unsigned.path,
+          "-key", ctx.file._key.path,
+          "-config", ctx.file.config.path,
+          "-out", ctx.outputs.executable.path,
+      ],
+  )
+  return [DefaultInfo(files=depset([ctx.outputs.executable])),
+          enclave_info(), sgx_enclave_info()]
+
+# Skylark rule for the above implementation. Gives default debug arguments for
+# private attributes for signing tool, signing key, and signing configuration.
+_sgx_debug_sign_enclave = rule(
+    implementation=_sgx_debug_sign_enclave_impl,
+    executable=True,
+    attrs={"unsigned": attr.label(allow_single_file=True),
+           "config": attr.label(mandatory=True, allow_single_file=True,
+                                providers=[sgx_enclave_config]),
+           "_sign_tool": attr.label(
+               default=Label("@linux_sgx//:sgx_sign_tool"),
+               allow_single_file=True, executable=True, cfg="host"),
+           "_key": attr.label(
+               default=Label(
+                   "@linux_sgx//:enclave_test_private.pem"),
+               allow_single_file=True),
+          })
+
+def sgx_enclave(name,
+                config = "@linux_sgx//:enclave_debug_config",
+                testonly = 0,
+                **kwargs):
+  """Build rule for creating SGX enclave shared object files signed for testing.
+
+  The enclave is signed with test key stored in
+  @linux_sgx//:enclave_test_private.pem.
+
+  This macro creates two build targets:
+    1) name_unsigned.so: cc_binary that builds the unsigned enclave.
+    2) name: internal signing rule that (debug) signs name_unsigned.so.
+
+  Args:
+    name: The debug-signed enclave target name.
+    config: An sgx_enclave_configuration rule.
+    testonly: 0 or 1, set to 1 if the target is only used in tests.
+    **kwargs: cc_binary arguments.
+  Returns:
+    string: The name of the signed enclave.
+  """
+  unsigned_name = _unsigned_enclave_name(name)
+
+  _sgx_unsigned_enclave(name = unsigned_name,
+                        testonly = testonly, **kwargs)
+
+  _sgx_debug_sign_enclave(name = name,
+                          unsigned = unsigned_name,
+                          config = config,
+                          testonly = testonly)
+
+  return name
+
+
+
+def _extend_enclave_name(enclave, str):
+  """Injects 'str' before '.so' if '.so' in enclave, otherwise appends 'str.so'.
+
+  Args:
+    enclave: Input string
+    str: String to append.
+
+  Returns:
+    string: Name of enclave with str appended.
+  """
+  if ".so" not in enclave:
+    return enclave + str + ".so"
+  else:
+    return enclave.replace(".so", str + ".so", 1)
+
+def _unsigned_enclave_name(enclave):
+  return _extend_enclave_name(enclave, "_unsigned")
--- /dev/null
+++ enclave_test_private.pem
@@ -0,0 +1,39 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIG4wIBAAKCAYEA1HFuEuAUujRr1b21s1KCpbFoN6I64jqcMw+DzZ1fJVjUnKHS
+NTHX7fBXHsILUKfhOKKtas2SQoMdb9l+xpTW8N2tiJ6jwY6FEhJujSx395eTf6q2
+Uktn5l0KJySeO0jO7NI8R9vlcIvF8mMpAcP5COjv4w10NetiH2eHQUD4PIFJFEPx
+W92lwTUXxzOYYgdSb6+rbcS1ti98SMltHiO9KBX3mfQKJMdX+zDMof2Ar7roplo7
+WbxLCTF95B5oAoZ5jnFySpOb8n7LAfkcHv7RSdIgpWR7bcetK33BZ3iwD05zeZ25
+os3PZLxv0ZHoi+4qwbQOdCdlln3mtOE/Hc9VfJb9fpKlaKXg7yd2bpm+dCjVk74U
+72fm+t7IjkI9Nfik8CTaqZsWwqrGqRoY/vHqiRlFotLKp1439PObsBg9cesrRPzL
+D5Umu1CcMcy9/yRIUMrOMJmwmb0Y5Lzzgzi6GX9GV5k//DGhHVlRETywcUouqZsO
+6hQS4utADELrgdQFAgEDAoIBgQCNoPQMlWMmzZ05KSPM4axudkV6bCdBfGgiClfe
+aOoY5eMTFowjdo/z9Y9p1rI1xUDQbHOciQwsV2j1O6nZuI9LPnOwacKBCa4MDEmz
+cvqlD7eqcc7hh5qZk1waGGl82zSd4X2FPUOgXS6hl3Cr1/tbRfVCCPgj8kFqRQTW
+K1AoVjC4LUuSk8PWI2Uvd7rsBOGfynJJLc55dP2F254UF9NwDqURTVwYhOVSIIhr
+/lXKfJsZkXzmfYdbdlPtaZqsWaUnX/L+mUVVgwcTEH21Lwxl95VnwoLWP/bAM/Zg
+OS7Ij1i/EC4WHBeKbM8WVlhqwlfvSzeyrL1IC4+eqZutDcfBpwtE2VX/78wEt7OL
+a8AeXbOD82X+vtyk3eSWg7OBe4LKa3CsECKVd6rdUEY0/hx/NFoqnH/sO+tIMCmF
+V970BjcP06hvVxvjTw2vucEcPYCXCijBRzAR3I48OBAenQeSql9J4SIxxkJ3Caip
+HVHxI7xtkcEBwOZ+vWGb7c/hhasCgcEA+LelnmVb1XyskmSazik1WzsgydHWxmiz
+VwhWW6PE9Eiy7vNzuuUW6g+Sc7TQ4MMISFTOxxdsPmH9YfKEkNQdTlBgNQf7F5ZB
+K1sMs2/ZCleA9yxOqF8+cFnW78XwLhRDdiZLzs+R+qWKsLqWt1t0GqorZXotmGdl
+eEdc5e5poUnyukJeFhhbgtOM3y5mIqA4Tr3gnu4V6MvIzDRACyIq9VgXzwx4Kv/X
+ZqJcX0LK8DBJu0DnZgfa6y+7HikkGsRlAoHBANqp4C5IWBy9k9L7xMEPCVWjn7/u
+4GX/B7QneXt/JO4uu2wSAMa+lSsJprxbkwsHnpJubCEM3WwKkeTwUQlmjIvMDGJE
+qVEn7by43GoIRTxEx1akrUjqXZM4Gry2v8WrHUpdZdizUOfRu6xnGPgZS6+gkv1t
+3Syc8ZBkAIImBWKX5fL88FJ6IWOGessHtjInzx99sG/A0pYmer40m0orA8gnn5m7
+FIaIZgQod7RN6pdkSkn/hgFq3jmfcoQ1D5THIQKBwQClz8O+7j04/chhmGc0G3jn
+fMCGi+SERczksDmSbS34MHdJ96J8mLnxX7b3zeCV11ra4zSEukgplqjr9wMLOBOJ
+iurOBVIPuYDHkgh3n+YG5QCkyDRwP371kTn1LqAeuCz5bt00imFRw7HLJw8k56K8
+cXJDpskQRO5QL5ND9EZrhqHRgZQOuuesjQiUyZlsatA0fpW/SWPwh9syzYAHbByj
+kA/fXaVx/+TvFug/gdygIDEngJpEBTycyny+xhgR2EMCgcEAkcaVdDA6vdO34f0t
+1goGORe/1Unq7qoFIsT7p6oYnsnSSAwAhH8OHLEZ0ue3XK+/DEmda13o8rG2mKA2
+BkRdsogIQYMbi2/z0yXoRrAuKC3aOcMeMJw+YiVnKHnVLnIThujukHeLRTZ9HZoQ
+pWYydRW3U56TcxNLtZgAVsQDlw/uof31jFFrl678h1p5dsU0v6kgSoCMZBmnKXhn
+hsdX2sUVESdjBFrurXBPzYlHD5gxhqpZVkc+0RT3As4KYy9rAoHAESOVy2qTeocF
+pThKcaDdLWNgCZGUMg0zXsdjbVn83AI9gC0Z7qVTB+9Se4mcokgRk5sJpaEh9qNv
+1Z4Div2+fvSCgY7bRL6wvFv102p8Q6CoLLMqGY4Vs1V7ZMIPw+t05kyWyejkV6D2
+jV8q86FVdKauCW/kaYMNaJZgVALAxXOIVkTWv1rwbD/x6jgg0ci2edZP6SbK5m+2
+ZOlE563ecaOVv6OSErYE1Eg6MbvjPMNZ+uIlPKYPIocy7FZQxRHY
+-----END RSA PRIVATE KEY-----
--- /dev/null
+++ runtime_support/rts_config.h
@@ -0,0 +1,30 @@
+#ifndef THIRD_PARTY_LINUX_SGX_RUNTIME_RTS_CONFIG_H_
+#define THIRD_PARTY_LINUX_SGX_RUNTIME_RTS_CONFIG_H_
+
+#include <string.h>
+
+#ifndef _ERNNO_T_DEFINED
+#define _ERRNO_T_DEFINED
+typedef int errno_t;
+#endif
+
+#ifndef HAVE_SET_UCONTEXT
+#define HAVE_SET_UCONTEXT
+ #ifndef __linux__
+ #define __linux__
+ #endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+errno_t memset_s(void *s, size_t smax, int c, size_t n);
+
+int consttime_memequal(const void *b1, const void *b2, size_t len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // THIRD_PARTY_LINUX_SGX_RUNTIME_RTS_CONFIG_H_
--- /dev/null
+++ runtime_support/sgx_init_string_lib.c
@@ -0,0 +1,8 @@
+
+#include <stdint.h>
+
+int __NR_rt_sigprocmask;
+
+int sgx_init_string_lib(uint64_t cpu_feature_indicator) {
+  return 0;
+}
