/*
 *
 * Copyright 2018 Asylo authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// EDL file for enclave infrastructure. Defines function calls across enclave
// boundary. The "trusted" scope defines "ecall" functions that are called on
// the host side and enter the enclave and execute inside it. The "untrusted"
// scope defines "ocall" functions transition across the enclave boundary in the
// opposite direction - called from within enclave, executed on the host side.
//
// See generate_bridge.sh for build instruction.
//
// In addition, new function definitions must be added to untrusted/ocalls.cc
// and to trusted/ecalls.cc for untrusted and trusted functions respectively.
//
// Once new functions are defined and generated, user-friendly wrappers need to
// be added to untrusted/enclave_calls.* and trusted/host_calls.* respectively.
enclave {
  include "asylo/platform/common/bridge_types.h"
  include "asylo/platform/core/shared_name_kind.h"

  from "../../../third_party/intel/sgx_tstdc.edl" import
      sgx_thread_wait_untrusted_event_ocall,
      sgx_oc_cpuidex,
      sgx_thread_set_untrusted_event_ocall,
      sgx_thread_setwait_untrusted_events_ocall,
      sgx_thread_set_multiple_untrusted_events_ocall;

  from "../../../platform/primitives/sgx/bridge.edl" import *;
  from "../../../platform/primitives/sgx/errno.edl" import *;
  from "host_calls_generator/generated_bridge.edl" import *;

  // Unless otherwise specified, each of the following calls invokes the
  // corresponding function on the host.
  untrusted {
    //////////////////////////////////////
    //              IO                  //
    //////////////////////////////////////

    void **ocall_enc_untrusted_allocate_buffers(bridge_size_t count,
        bridge_size_t size) propagate_errno;
    void ocall_enc_untrusted_deallocate_free_list([user_check] void **free_list,
        bridge_size_t count) propagate_errno;

    //////////////////////////////////////
    //           inotify.h              //
    //////////////////////////////////////

    int ocall_enc_untrusted_inotify_read(int fd, bridge_size_t count,
        [out] char **serialized_events,
        [out] bridge_size_t *serialized_events_len) propagate_errno;

    //////////////////////////////////////
    //            signal.h              //
    //////////////////////////////////////

    int ocall_enc_untrusted_register_signal_handler(
        int bridge_signum, [in] const struct BridgeSignalHandler *handler,
        [in, string] const char *name);

    //////////////////////////////////////
    //          sys/syslog.h            //
    //////////////////////////////////////

    void ocall_enc_untrusted_openlog([in, string] const char *ident, int option,
                                     int facility);

    void ocall_enc_untrusted_syslog(int priority,
                                    [in, string] const char *message);

    //////////////////////////////////////
    //            unistd.h              //
    //////////////////////////////////////

    pid_t ocall_enc_untrusted_fork(
        [in, string]const char *enclave_name,
	      bool restore_snapshot)
	allow(ecall_take_snapshot, ecall_restore) propagate_errno;
  };

};
