/*
 *
 * Copyright 2019 Asylo authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#ifndef ASYLO_PLATFORM_PRIMITIVES_MESSAGE_H_
#define ASYLO_PLATFORM_PRIMITIVES_MESSAGE_H_

#include <functional>
#include <memory>
#include <vector>
#include <cstring>

#include "asylo/platform/primitives/extent.h"

namespace asylo {
namespace primitives {

// A message serialization implementation to allow the users to pass input data
// via extents and generate a serialized message. The MessageReader is a
// serialization utility designed to make it easier and safer to pass structured
// data over the enclave boundary. The extents pushed to the MessageWriter are
// serialized using |Write()|, passed across the enclave boundary and
// deserialized using the MessageReader for consumption. The message is simply
// comprised of a data pointer and the size.
// The message writer only allows pushing extents or values to it; reading data
// from the writer is disallowed. The message writer does not perform memory
// allocation for the serialized message. Extents can be pushed by reference or
// by copy, in which case they are owned by the MessageWriter.
class MessageWriter {
 public:
  MessageWriter() = default;

  // Disallow copying.
  MessageWriter(const MessageWriter &other) = delete;
  MessageWriter operator=(const MessageWriter &other) = delete;

  // Allow moving.
  MessageWriter(MessageWriter &&other) noexcept = default;
  MessageWriter &operator=(MessageWriter &&other) = default;

  // Returns true if no output has been written to the MessageWriter.
  bool empty() const { return extents_.empty(); }

  // Returns the number of extents pushed on the writer.
  size_t size() const { return extents_.size(); }

  // Returns the size of serialized message generated by write().
  size_t MessageSize() const {
    size_t result = sizeof(uint64_t) * extents_.size();
    for (const auto &extent : extents_) {
      result += extent.size();
    }
    return result;
  }

  // Generates and writes a serialized message into a buffer owned by the
  // caller. |*message| must be at least MessageSize() bytes long. The
  // encoding scheme is simply repeated sequence of extent size as uint64_t
  // followed by extent data.
  void Write(void *message) const {
    auto ptr = reinterpret_cast<char *>(message);
    for (const auto &extent : extents_) {
      uint64_t size = extent.size();

      memcpy(ptr, &size, sizeof(uint64_t));  // Copy data size.
      ptr += sizeof(uint64_t);
      memcpy(ptr, extent.data(), size);  // Copy data.
      ptr += size;
    }
  }

  // Pushes an extent to the MessageWriter by reference.
  void PushByReference(Extent extent) { extents_.emplace_back(extent); }

  // Pushes an extent to the MessageWriter by copy. Data is copied and owned by
  // the MessageWriter.
  void PushByCopy(Extent extent) {
    char *extent_data = new char[extent.size()];
    copied_data_owner_.emplace_back(extent_data);
    memcpy(extent_data, extent.data(), extent.size());
    PushByReference(Extent{extent_data, extent.size()});
  }

  // Pushes non-pointer data types (eg. ints, structs) by value. Internally
  // performs a copy, since the input value could go out of scope after being
  // pushed.
  template <typename T>
  void Push(const T &value) {
    static_assert(!std::is_pointer<T>::value,
                  "PushByValue should not be used with pointers");
    PushByCopy(Extent{const_cast<T *>(&value)});
  }

  // Pushes a string by copy (since the string could go out of scope after it is
  // pushed, before Write() is called.)
  void Push(const std::string &s) {
    PushByCopy(Extent{s.c_str(), s.size() + 1});  // Add 1 for null character.
  }

 private:
  std::vector<Extent> extents_;
  std::vector<std::unique_ptr<char[]>> copied_data_owner_;
};

// A message reader that consumes a serialized message and generates extents.
// The extent memory is owned by the class and freed with the destructor.
// Extents can be read from the MessageReader only once, and never written.
class MessageReader {
 public:
  MessageReader() = default;

  // Disallow copying.
  MessageReader(const MessageReader &other) = delete;
  MessageReader operator=(const MessageReader &other) = delete;

  // Allow moving.
  MessageReader(MessageReader &&other) noexcept = default;
  MessageReader &operator=(MessageReader &&other) = default;

  // Deserializes a data buffer of provided size into owned extents. |data| is
  // the serialized buffer written by the MessageWriter, and therefore is owned
  // by the user/runtime. |data| could be located in untrusted memory, and
  // therefore, transferring its ownership to trusted memory is non-trivial,
  // since trusted memory would then need to remotely manage untrusted memory.
  // This necessitates deserializing and copying |data| into new owned extents,
  // since MessageReader is expected to own its memory.
  MessageReader(const void *data, size_t size) {
    const char *ptr = reinterpret_cast<const char *>(data);
    const char *end_ptr = ptr + size;
    while (ptr < end_ptr) {
      uint64_t extent_len;
      memcpy(&extent_len, ptr, sizeof(uint64_t));
      ptr += sizeof(uint64_t);

      char *extent_data = new char[extent_len];
      extents_.emplace_back(std::unique_ptr<char[]>(extent_data), extent_len);
      memcpy(extent_data, ptr, extent_len);
      ptr += extent_len;
    }
  }

  // Returns the number of extents read.
  size_t size() const { return extents_.size(); }

  // Gets the next extent from the list of extents read. Extents can only be
  // traversed and returned once.
  Extent next() {
    Extent result = Extent{extents_[pos_].first.get(), extents_[pos_].second};
    pos_++;
    return result;
  }

 private:
  std::vector<std::pair<std::unique_ptr<char[]>, size_t>> extents_;
  int pos_ = 0;
};

}  // namespace primitives
}  // namespace asylo

#endif  // ASYLO_PLATFORM_PRIMITIVES_MESSAGE_H_
